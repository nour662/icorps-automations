{
 "awd_id": "1161821",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "SHF: Medium: Collaborative Research: Regression Testing Techniques for Real-world Software Systems",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2012-07-01",
 "awd_exp_date": "2019-06-30",
 "tot_intn_awd_amt": 875065.0,
 "awd_amount": 1103853.0,
 "awd_min_amd_letter_date": "2012-03-27",
 "awd_max_amd_letter_date": "2018-06-14",
 "awd_abstract_narration": "Reports estimate that regression testing, which is the activity of retesting a software system after it has been modified, can consume up to 50% of the cost of software development and maintenance. Although there are many techniques that can reduce the cost of regression testing, most of them do not account for important characteristics of modern systems, such as product lines, web applications, service-oriented architectures, and cloud-based applications.  These systems are increasingly heterogeneous: they may come from different sources, may be written in different languages, and may be accessible in different formats (e.g., source code, binary code, or through remote interfaces). Moreover, modern software is often environment dependent: its behavior can be affected not only by changes in the code, but also by changes in its complex environment (e.g., databases, configuration files, and network layouts).  Because most existing regression-testing techniques do not account for these characteristics, the application of these techniques can result in inadequately tested software, problems during maintenance, and ultimately poor software quality.\r\n\r\nThe overall goal of this research is to go beyond the state of the art in regression testing by defining novel approaches that can be applied to modern, real-world software and account for its characteristics and complexity. To achieve this goal, the research will first extend analysis techniques on which regression-testing approaches rely, such as system modeling, version differencing, coverage analysis, and impact analysis. The research will then leverage these fundamental techniques to develop, evaluate with industrial partners, and make available a family of regression testing techniques and tools that can (1) build comprehensive models of heterogeneous, environment-dependent software systems, (2) evolve these models throughout the systems' lifetimes, and (3) analyze the changes across models to understand their effects on the systems' behavior and retest them effectively and efficiently. The impact of the research will be manyfold. First, the rigorous, transformative, and highly automated techniques developed will help improve the quality of today's large, complex software systems, thus benefitting all segments of society that depend on software. Second, the release of the produced tools and infrastructure will let other researchers and practitioners build on our results, advancing knowledge and understanding. Finally, the research findings will be integrated in curriculum materials that will be made available to the broader scientific community, which will help prepare a globally competitive workforce and further benefit society.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Alessandro",
   "pi_last_name": "Orso",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Alessandro Orso",
   "pi_email_addr": "orso@cc.gatech.edu",
   "nsf_id": "000489660",
   "pi_start_date": "2012-03-27",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Mary",
   "pi_last_name": "Harrold",
   "pi_mid_init": "J",
   "pi_sufx_name": "",
   "pi_full_name": "Mary J Harrold",
   "pi_email_addr": "harrold@cc.gatech.edu",
   "nsf_id": "000248827",
   "pi_start_date": "2012-03-27",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Georgia Tech Research Corporation",
  "inst_street_address": "926 DALNEY ST NW",
  "inst_street_address_2": "",
  "inst_city_name": "ATLANTA",
  "inst_state_code": "GA",
  "inst_state_name": "Georgia",
  "inst_phone_num": "4048944819",
  "inst_zip_code": "303186395",
  "inst_country_name": "United States",
  "cong_dist_code": "05",
  "st_cong_dist_code": "GA05",
  "org_lgl_bus_name": "GEORGIA TECH RESEARCH CORP",
  "org_prnt_uei_num": "EMW9FC8J3HN4",
  "org_uei_num": "EMW9FC8J3HN4"
 },
 "perf_inst": {
  "perf_inst_name": "College of Computing",
  "perf_str_addr": "801 Atlantic Drive",
  "perf_city_name": "Atlanta",
  "perf_st_code": "GA",
  "perf_st_name": "Georgia",
  "perf_zip_code": "303320280",
  "perf_ctry_code": "US",
  "perf_cong_dist": "05",
  "perf_st_cong_dist": "GA05",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "164000",
   "pgm_ele_name": "Information Technology Researc"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794400",
   "pgm_ele_name": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1640",
   "pgm_ref_txt": "INFORMATION TECHNOLOGY RESEARC"
  },
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 191271.0
  },
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 683794.0
  },
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 228788.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>A considerable percentage of software development and maintenance costs are due to regression testing?retesting a software system after it is modified to assess whether the changes in the software behave as intended and have not introduced unwanted side effects. Both researchers and practitioners have defined many techniques for supporting regression-testing and improving its effectiveness and efficiency. Many of these techniques, however, make unrealistic assumptions on the software that is being tested or fall short when applied to modern software systems. The overall goal of this project was to go beyond the state of the art in regression testing by defining novel approaches that can be applied to modern, real-world software and account for its characteristics and complexity. The rest of this report summarizes a representative set of the techniques that were developed within the project.</p>\n<p><em>Improving in-house tests based on observed field behavior</em>. Regression testing, and testing in general, is inherently limited, as in-house tests can typically only exercise a tiny fraction of all possible software behaviors. Typically, developers make decisions on what to test and how based on some assumptions on how the software will be used in the field. When these assumptions are incorrect, which is a common occurrence, the test cases used in-house may not be representative of the software behavior that users actually exercise in the field. Moreover, even when these assumptions are accurate, it is often the case that testers have to compromise on the thoroughness of their tests due time and cost considerations. In fact, a study performed as part of this project investigated the representativeness of developer-written tests and confirmed that tests fail to cover much of the behavior exercised in the field. To make in-house tests more representative, this research developed a technique that aims to bridge the gap between in-house tests and field executions by mimicking observed, untested user behavior. Intuitively, the technique discovers untested behavior occurring in the field and generates new tests that exercise this relevant behavior. Empirical evaluations of the technique show that it can be effective in generating test suites that are representative of the way software is actually used and can therefore reveal more bugs than traditional test suites developed in-house.</p>\n<p><em>Automated test repair during code evolution</em>. A considerable fraction of the cost of regression testing comes from test-suite maintenance and, in particular, from the effort developers spend repairing ?broken test cases?. When tests break because of a change in the software but are still valid, they should be repaired. Moreover, a broken test should be repaired so that the repaired test exercises the same behavior as the original test. This can require considerable effort in terms of understanding the test cases and the functionality of the program being tested. To reduce the cost of test repair, this research developed a technique that can fix broken tests by performing non-trivial changes to the test code while preserving the intent of the tests. An empirical evaluation of this technique showed that the technique is effective in generating intent-preserving repaired test cases, including in cases where the repair involves dealing with significant program (and test) changes.</p>\n<p><em>Automated library migration for mobile apps</em>. In addition to regression errors due to changes in a software system, it is not uncommon to witness regressions that are due solely to changes in the environment (i.e., operating/runtime system and libraries). This is particularly frequent in the case of mobile apps, as these apps rely heavily on their underlying environment. Unfortunately, evolving an app to adapt it to environment changes is a tedious, error-prone, and time-consuming task, especially when the app must work on multiple versions of the environment (e.g., multiple versions of the OS). To mitigate this problem, this research developed a technique that can learn how to update an app to adapt it to a given set of environment changes by (1) analyzing examples of corresponding updates on other apps, (2) synthesizing suitable code transformations, and (2) applying these transformations to the app to be updated. Empirical evaluations of this approach show that it can be successfully applied to real-world apps and real changes in their environment, thus potentially saving a considerable amount of developers? effort during software evolution.</p>\n<p><strong>Broader impact:</strong> In addition to disseminating the results of this research through publications, public presentations, and integration into the curriculum, this research made freely available to researchers and practitioners tools, data, and experiment infrastructure developed within the project, which will help further dissemination and enable future research. More generally, by advancing the state of the art in the areas of regression testing and software engineering in general, this research helped and will help developers build more reliable software systems, ultimately increasing the overall quality of our software infrastructure and providing benefits to all segments of society that depend on software.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 01/26/2020<br>\n\t\t\t\t\tModified by: Alessandro&nbsp;Orso</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nA considerable percentage of software development and maintenance costs are due to regression testing?retesting a software system after it is modified to assess whether the changes in the software behave as intended and have not introduced unwanted side effects. Both researchers and practitioners have defined many techniques for supporting regression-testing and improving its effectiveness and efficiency. Many of these techniques, however, make unrealistic assumptions on the software that is being tested or fall short when applied to modern software systems. The overall goal of this project was to go beyond the state of the art in regression testing by defining novel approaches that can be applied to modern, real-world software and account for its characteristics and complexity. The rest of this report summarizes a representative set of the techniques that were developed within the project.\n\nImproving in-house tests based on observed field behavior. Regression testing, and testing in general, is inherently limited, as in-house tests can typically only exercise a tiny fraction of all possible software behaviors. Typically, developers make decisions on what to test and how based on some assumptions on how the software will be used in the field. When these assumptions are incorrect, which is a common occurrence, the test cases used in-house may not be representative of the software behavior that users actually exercise in the field. Moreover, even when these assumptions are accurate, it is often the case that testers have to compromise on the thoroughness of their tests due time and cost considerations. In fact, a study performed as part of this project investigated the representativeness of developer-written tests and confirmed that tests fail to cover much of the behavior exercised in the field. To make in-house tests more representative, this research developed a technique that aims to bridge the gap between in-house tests and field executions by mimicking observed, untested user behavior. Intuitively, the technique discovers untested behavior occurring in the field and generates new tests that exercise this relevant behavior. Empirical evaluations of the technique show that it can be effective in generating test suites that are representative of the way software is actually used and can therefore reveal more bugs than traditional test suites developed in-house.\n\nAutomated test repair during code evolution. A considerable fraction of the cost of regression testing comes from test-suite maintenance and, in particular, from the effort developers spend repairing ?broken test cases?. When tests break because of a change in the software but are still valid, they should be repaired. Moreover, a broken test should be repaired so that the repaired test exercises the same behavior as the original test. This can require considerable effort in terms of understanding the test cases and the functionality of the program being tested. To reduce the cost of test repair, this research developed a technique that can fix broken tests by performing non-trivial changes to the test code while preserving the intent of the tests. An empirical evaluation of this technique showed that the technique is effective in generating intent-preserving repaired test cases, including in cases where the repair involves dealing with significant program (and test) changes.\n\nAutomated library migration for mobile apps. In addition to regression errors due to changes in a software system, it is not uncommon to witness regressions that are due solely to changes in the environment (i.e., operating/runtime system and libraries). This is particularly frequent in the case of mobile apps, as these apps rely heavily on their underlying environment. Unfortunately, evolving an app to adapt it to environment changes is a tedious, error-prone, and time-consuming task, especially when the app must work on multiple versions of the environment (e.g., multiple versions of the OS). To mitigate this problem, this research developed a technique that can learn how to update an app to adapt it to a given set of environment changes by (1) analyzing examples of corresponding updates on other apps, (2) synthesizing suitable code transformations, and (2) applying these transformations to the app to be updated. Empirical evaluations of this approach show that it can be successfully applied to real-world apps and real changes in their environment, thus potentially saving a considerable amount of developers? effort during software evolution.\n\nBroader impact: In addition to disseminating the results of this research through publications, public presentations, and integration into the curriculum, this research made freely available to researchers and practitioners tools, data, and experiment infrastructure developed within the project, which will help further dissemination and enable future research. More generally, by advancing the state of the art in the areas of regression testing and software engineering in general, this research helped and will help developers build more reliable software systems, ultimately increasing the overall quality of our software infrastructure and providing benefits to all segments of society that depend on software.\n\n\t\t\t\t\tLast Modified: 01/26/2020\n\n\t\t\t\t\tSubmitted by: Alessandro Orso"
 }
}