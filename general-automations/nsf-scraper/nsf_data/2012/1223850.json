{
 "awd_id": "1223850",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "TWC: Small: New Foundations for Secure JavaScript",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2012-09-01",
 "awd_exp_date": "2017-08-31",
 "tot_intn_awd_amt": 400000.0,
 "awd_amount": 400000.0,
 "awd_min_amd_letter_date": "2012-09-04",
 "awd_max_amd_letter_date": "2012-09-04",
 "awd_abstract_narration": "JavaScript has transformed the way in which software systems are developed, deployed and extended. It is now used to build complex, security sensitive applications for communications, retail, and banking, and is even a primary building block of web browsers themselves. Unfortunately, the advent of JavaScript has also opened the door to new classes of security vulnerabilities, as applications manipulate security critical client information like browsing history, passwords, bank account numbers, social security numbers and so on. Worse, the absence of language-level isolation mechanisms makes it hard to establish confidentiality and integrity of key software components.\r\n\r\nWe believe that the key to making the web more secure is to develop a practical, precise and expressive type system for JavaScript and to use it as a foundation for developing security policies, analyses and enforcement mechanisms for JavaScript browser extensions and applications. Thus, we propose to develop a type system for JavaScript that is expressive enough to support JavaScript's dynamic idioms, practical enough to require minimal programmer intervention and hence, be capable of highly automated analysis of large code bases, and easily extensible enough to allow developers to specify and enforce different kinds of fine-grained security policies.\r\n\r\nOur research will lead to the following contributions: End Users will be able to freely run extensions, plugins and rich browser applications from trusted sites, without having to suffer the plagues of code-injection, information exfiltration or the unpalatable cures of fully dynamic enforcement whose overhead can render sites unusable.  Developers will be able to fully enjoy the fruits of static verification, in a familiar package: namely types. Types will allow developers to specify at the right granularity, the permissions required for some functionality, and will prevent the inadvertent vulnerabilities that are introduced by overprovisioning, or under-sanitization of data.  Curators that aggregate third party applications (e.g. ``app stores\" for various mobile platforms) will be able to use type-based certificates to quickly vet applications, thereby determining if an application is safe to host without compromising the reputation of the platform.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Ranjit",
   "pi_last_name": "Jhala",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Ranjit Jhala",
   "pi_email_addr": "jhala@cs.ucsd.edu",
   "nsf_id": "000486287",
   "pi_start_date": "2012-09-04",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-San Diego",
  "inst_street_address": "9500 GILMAN DR",
  "inst_street_address_2": "",
  "inst_city_name": "LA JOLLA",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "8585344896",
  "inst_zip_code": "920930021",
  "inst_country_name": "United States",
  "cong_dist_code": "50",
  "st_cong_dist_code": "CA50",
  "org_lgl_bus_name": "UNIVERSITY OF CALIFORNIA, SAN DIEGO",
  "org_prnt_uei_num": "",
  "org_uei_num": "UYTTZT6G9DT1"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-San Diego",
  "perf_str_addr": "9500 Gilman Drive",
  "perf_city_name": "La Jolla",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "920930404",
  "perf_ctry_code": "US",
  "perf_cong_dist": "50",
  "perf_st_cong_dist": "CA50",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7434",
   "pgm_ref_txt": "CNCI"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 400000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><br /><br /><br /># Project Outcomes<br /><br />This project led to the invention of new algorithms and tools<br />for analyzing programs written in JavaScript, the language of<br />the web. Specifically, it led to to the development of the<br />open-source RefScript system, a _Refinement Type_ system for<br />for the _TypeScript_ dialect of JavaScript that is being developed<br />by Microsoft.<br /><br />In the project, we demonstrated how the RefScript can be used<br />to improve the quality of JavaScript programs in several ways.<br />First, the developer can use refinement types to completely<br />eliminate large and expensive classes of errors that can<br />either cause application code to crash or fail in unexpected<br />and hard to find ways, or worse, may be vulnerabilities that<br />can be exploited by an attacker.<br />Second, the developer can encode, within the program, detailed<br />constraints on _how_ the program should be used, via refined API<br />specifications, that then enable the construction and composition<br />of larger systems.<br /><br />We achieved this by developing and implementing several key ideas.<br /><br />## Aliased Refinement Types (VMCAI 2016)<br /><br />First, we developed the notion of _aliased refinement types_<br />a new approach to automate the verification of correctness<br />properties of pointer-based data structures. While there are<br />many techniques for checking that pointer-manipulating programs<br />adhere to their specifications, they often require that the<br />programmer annotate the behavior of each procedure,<br />for example, in the form of loop invariants and pre-<br />and post-conditions. We introduce a technique that<br />automates this step by factoring the analysis of data<br />structures into two orthogonal components:<br /><br />(1) Alias Types, which reason about the _shape_ of<br />&nbsp;&nbsp;&nbsp; pointer structures, and<br />(2) Refinement Types, which use simple predicates<br />&nbsp;&nbsp;&nbsp; from decidable theories to capture the semantic<br />&nbsp;&nbsp;&nbsp; properties of the structures.<br /><br />We empirically show, using a suite of data-structure<br />benchmarks, that our approach reduces the programmer<br />effort needed for verification by a factor of 4.<br /><br />## Trust, but Verify: Two-Phased Typing<br /><br />The second crucial challenge for analyzing _dynamic_<br />languages like JavaScript, is that programs can, while<br />running, have different _types_ depending on the the<br />_values_ of various run-time parameters. We carried<br />out a study that demonstrated that this form of<br />introspection, that we named \"value-based<br />overloading\" is ubiquitous in JavaScript libraries.<br />Value based overloading thwarts&nbsp; previous analysis<br />attempts as to establish basic types, the analysis<br />must reason precisely about values, but in the<br />presence of advanced language constructs (e.g.<br />higher-order functions and polymorphism, this<br />reasoning itself can require basic types.)<br /><br />We invented the framework of \"two-phased typing\" to cut<br />this knot. The first \"trust\" phase performs classical<br />type checking to assign basic types to various program<br />expressions. When the check inevitably runs into \"errors\"<br />it marks problematic expressions to explicate the trust<br />obligations that must be discharged by the second phase,<br />which uses refinement typing to establish correctness.<br /><br />## SSA-Refinement Typing<br /><br />Our third key contribution was to show how the above<br />can be scaled up to yield a lightweight refinement type<br />system for the TypeScript superset of JavaScript, yielding<br />RSC the _first static verifier_ for the language of the web.<br />To do so, we carefully formalized the interaction<br />between refinement types and mutability and show how<br />to recover sensitivity by translating input programs<br />to an equivalent SSA form. We then demonstrated how to<br />scale the formalism up to account for imperative and<br />dynamic features of TypeScript, including overloading,<br />type reflection, ad hoc type hierarchies and object<br />initialization.<br /><br />Finally, we evaluated RSC on a set of real-world benchmarks,<br />including parts of the Octane benchmarks, D3, Transducers,<br />and the TypeScript compiler. We showed how RSC successfully<br />establishes a number of value dependent properties, such<br />as the safety of array accesses and downcasts, while<br />incurring a modest overhead in type annotations and code<br />restructuring.<br /><br />## Overall Outcomes<br /><br />Consequently, this project has demonstrated comprehensively<br />the viability of building effective static verifiers, capable<br />of enforcing correctness and security properties, for a<br />modern, imperative, scripting language that powers the web.<br />The lead student on the project -- Panagiotis Vekris -- has<br />graduated and is now part of the \"Flow\" team at Facebook.<br />Other research groups have picked up on this foundational <br />work and are using it to build higher level secure web<br />frameworks for JavaScript.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/04/2017<br>\n\t\t\t\t\tModified by: Ranjit&nbsp;Jhala</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n\n\n\n# Project Outcomes\n\nThis project led to the invention of new algorithms and tools\nfor analyzing programs written in JavaScript, the language of\nthe web. Specifically, it led to to the development of the\nopen-source RefScript system, a _Refinement Type_ system for\nfor the _TypeScript_ dialect of JavaScript that is being developed\nby Microsoft.\n\nIn the project, we demonstrated how the RefScript can be used\nto improve the quality of JavaScript programs in several ways.\nFirst, the developer can use refinement types to completely\neliminate large and expensive classes of errors that can\neither cause application code to crash or fail in unexpected\nand hard to find ways, or worse, may be vulnerabilities that\ncan be exploited by an attacker.\nSecond, the developer can encode, within the program, detailed\nconstraints on _how_ the program should be used, via refined API\nspecifications, that then enable the construction and composition\nof larger systems.\n\nWe achieved this by developing and implementing several key ideas.\n\n## Aliased Refinement Types (VMCAI 2016)\n\nFirst, we developed the notion of _aliased refinement types_\na new approach to automate the verification of correctness\nproperties of pointer-based data structures. While there are\nmany techniques for checking that pointer-manipulating programs\nadhere to their specifications, they often require that the\nprogrammer annotate the behavior of each procedure,\nfor example, in the form of loop invariants and pre-\nand post-conditions. We introduce a technique that\nautomates this step by factoring the analysis of data\nstructures into two orthogonal components:\n\n(1) Alias Types, which reason about the _shape_ of\n    pointer structures, and\n(2) Refinement Types, which use simple predicates\n    from decidable theories to capture the semantic\n    properties of the structures.\n\nWe empirically show, using a suite of data-structure\nbenchmarks, that our approach reduces the programmer\neffort needed for verification by a factor of 4.\n\n## Trust, but Verify: Two-Phased Typing\n\nThe second crucial challenge for analyzing _dynamic_\nlanguages like JavaScript, is that programs can, while\nrunning, have different _types_ depending on the the\n_values_ of various run-time parameters. We carried\nout a study that demonstrated that this form of\nintrospection, that we named \"value-based\noverloading\" is ubiquitous in JavaScript libraries.\nValue based overloading thwarts  previous analysis\nattempts as to establish basic types, the analysis\nmust reason precisely about values, but in the\npresence of advanced language constructs (e.g.\nhigher-order functions and polymorphism, this\nreasoning itself can require basic types.)\n\nWe invented the framework of \"two-phased typing\" to cut\nthis knot. The first \"trust\" phase performs classical\ntype checking to assign basic types to various program\nexpressions. When the check inevitably runs into \"errors\"\nit marks problematic expressions to explicate the trust\nobligations that must be discharged by the second phase,\nwhich uses refinement typing to establish correctness.\n\n## SSA-Refinement Typing\n\nOur third key contribution was to show how the above\ncan be scaled up to yield a lightweight refinement type\nsystem for the TypeScript superset of JavaScript, yielding\nRSC the _first static verifier_ for the language of the web.\nTo do so, we carefully formalized the interaction\nbetween refinement types and mutability and show how\nto recover sensitivity by translating input programs\nto an equivalent SSA form. We then demonstrated how to\nscale the formalism up to account for imperative and\ndynamic features of TypeScript, including overloading,\ntype reflection, ad hoc type hierarchies and object\ninitialization.\n\nFinally, we evaluated RSC on a set of real-world benchmarks,\nincluding parts of the Octane benchmarks, D3, Transducers,\nand the TypeScript compiler. We showed how RSC successfully\nestablishes a number of value dependent properties, such\nas the safety of array accesses and downcasts, while\nincurring a modest overhead in type annotations and code\nrestructuring.\n\n## Overall Outcomes\n\nConsequently, this project has demonstrated comprehensively\nthe viability of building effective static verifiers, capable\nof enforcing correctness and security properties, for a\nmodern, imperative, scripting language that powers the web.\nThe lead student on the project -- Panagiotis Vekris -- has\ngraduated and is now part of the \"Flow\" team at Facebook.\nOther research groups have picked up on this foundational \nwork and are using it to build higher level secure web\nframeworks for JavaScript.\n\n\t\t\t\t\tLast Modified: 12/04/2017\n\n\t\t\t\t\tSubmitted by: Ranjit Jhala"
 }
}