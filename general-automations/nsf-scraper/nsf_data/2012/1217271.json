{
 "awd_id": "1217271",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: A Practical Program Transformation Infrastructure for C in the Presence of Multiple Configurations",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2012-09-01",
 "awd_exp_date": "2015-08-31",
 "tot_intn_awd_amt": 395646.0,
 "awd_amount": 424446.0,
 "awd_min_amd_letter_date": "2012-08-31",
 "awd_max_amd_letter_date": "2014-04-14",
 "awd_abstract_narration": "Over the last decade, the field of Software Engineering has seen a rapid and widespread adoption of automated refactoring tools: tools that analyze the source code under the direction of the programmer, and make systematic changes to that program that improve its internal structure without affecting its behavior. In the C programming language, which is one of the most popular languages in use, there is only a limited portfolio of refactorings available, with limited scalability and limited applicability to real-world programs. This research will address the technical problems that make it difficult to build automated refactoring tools (and other program transformation tools) for C: the ability to \"configure\" C programs using preprocessor macros, the need to perform sophisticated analyses in the presence of many such configurations, and the need to analyze and transform C when it is mixed with other programming languages. Solving these problems, and producing a tool that incorporates these solutions, will provide much needed tool improvements for C programmers.\r\n\r\nThe research will culminate in a prototype refactoring and program transformation tool for C that addresses the aforementioned problems. Handling multiple preprocessor configurations will involve the exploration of both a parsing algorithm and a program representation: the parsing algorithm extends the LALR(1) algorithm to handle preprocessor directives, while the program representation accommodates multiple configurations in a single abstract syntax tree (AST). Semantic information (from various static analyses) will be superimposed on the AST; however, this will require extending the static analyses to handle the complications presented by multiple preprocessor configurations. The tool will also allow for transforming mixed-language C programs--in particular, C programs mixed with Fortran or Yacc (two languages that are commonly combined with C). Handling multiple languages may be treated as an extension of the multiple configurations problem, where declarations in one language and definitions in a different language are treated, at least conceptually, as different configurations. The tool will be available under an open source license.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Munawar",
   "pi_last_name": "Hafiz",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Munawar Hafiz",
   "pi_email_addr": "munawar@auburn.edu",
   "nsf_id": "000600717",
   "pi_start_date": "2012-08-31",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Auburn University",
  "inst_street_address": "321-A INGRAM HALL",
  "inst_street_address_2": "",
  "inst_city_name": "AUBURN",
  "inst_state_code": "AL",
  "inst_state_name": "Alabama",
  "inst_phone_num": "3348444438",
  "inst_zip_code": "368490001",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "AL03",
  "org_lgl_bus_name": "AUBURN UNIVERSITY",
  "org_prnt_uei_num": "DMQNDJDHTDG4",
  "org_uei_num": "DMQNDJDHTDG4"
 },
 "perf_inst": {
  "perf_inst_name": "Auburn University",
  "perf_str_addr": "3101 Shelby Center",
  "perf_city_name": "Auburn",
  "perf_st_code": "AL",
  "perf_st_name": "Alabama",
  "perf_zip_code": "368490001",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "AL03",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794400",
   "pgm_ele_name": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 395646.0
  },
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 14400.0
  },
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 14400.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><div title=\"Page 1\">\n<div>\n<div>\n<p>Popular programming languages, e.g.,  Java, have support for maintenance and code evolution using automated  program transformations. C, in spite of its popularity, has IDEs with a  limited portfolio of program transformations, with limited scalability  and limited applicability to real-world programs&mdash;particularly ones that  make extensive use of the C preprocessor. Moreover, many C programs are  actually mixed-language programs, e.g., C programs with compute kernels  written in Fortran. However, the number of tools that correctly handle  such programs is zero.&nbsp;</p>\n<div title=\"Page 1\">\n<div>\n<div>\n<p>The problem  lies in the underlying infrastructure for analyzing and transforming C  source code. There are three reasons why it is hard to build such tools  for C. First, it is hard to handle multiple preprocessor configurations,  e.g., debug vs. release, Windows vs. Linux,&nbsp;x86 vs.&nbsp;x86 64, etc. Almost  all existing C program transformation tools present in IDEs work on a  single configuration of preprocessed code. This is inaccurate. For  example, a tool that applies a rename refactoring to a variable in one  configuration but ignores other configurations may change the behavior  of a program. Second, existing IDEs do not support sophisticated static  analyses on C source code, simultaneously handling all preprocessor  configurations. Third, no existing infrastructure handles multiple  programming languages, although modern programs often use more than one  language. Failure to cross the language boundary may make some program  transformations inaccurate.&nbsp;</p>\n</div>\n</div>\n</div>\n<div title=\"Page 6\">\n<div>\n<div>\n<div title=\"Page 1\">\n<div>\n<div>\n<p>The  PI proposed a program transformation infrastructure for C (named  OpenRefactory/C) that can handle these challenges.&nbsp;The research effort  has led to several innovations.</p>\n<p>&nbsp;</p>\n<ul>\n<li>A  parsing algorithm and program representation for handling multiple  preprocessor configurations. The language-agnostic parsing algorithm  allows any LALR(1) parser to parse code with multiple configurations and  represent programs in a single abstract syntax tree (AST).</li>\n<li>Representation  of semantic information (from static analyses) via directed edges  superimposed on the AST, but acknowledging the complications presented  by multiple configurations.</li>\n<li>A theoretical foundation for  verifying correctness of program transformations that considers  preservation of C code semantics and preprocessor semantics after the  transformation.</li>\n<li>A mechanism to test implemented refactorings by  applying them on real programs. This testing mechanism has been adopted  by Eclipse to test their implemented refactorings.</li>\n</ul>\n<p>&nbsp;</p>\n<p>The  work has led to 6 research papers, a best research award at the ACM  Student Research Competition Grand Finals, a nomination for the ACM  Distinguished Paper Award, two other ACM Student Research awards, two  research demos, and several talks at academia and industry (UIUC,  Arizona State, Oregon State, Google Inc., Coverity, etc.,).</p>\n<div title=\"Page 1\">\n<div>\n<div>\n<p><strong>Intellectual Merit.&nbsp;</strong>The  proposed work led to new algorithms and data structures needed to  implement scalable, robust automated program transformation tools for C.  It focused on the parts of this problem that have been inadequately  addressed in prior work&mdash; specifically, sound handling of the C  preprocessor and handling of mixed-language codes. The proposed research  addressed fundamental problems whose solutions would be essential for  researchers to investigate automated transformations for increasingly  complex software systems.</p>\n<p><strong>Broader Impact.&nbsp;</strong>Successfully  addressing the limitations present in existing tools and providing a  robust program transformation infrastructure will ...",
  "por_txt_cntn": "\n\n\n\nPopular programming languages, e.g.,  Java, have support for maintenance and code evolution using automated  program transformations. C, in spite of its popularity, has IDEs with a  limited portfolio of program transformations, with limited scalability  and limited applicability to real-world programs&mdash;particularly ones that  make extensive use of the C preprocessor. Moreover, many C programs are  actually mixed-language programs, e.g., C programs with compute kernels  written in Fortran. However, the number of tools that correctly handle  such programs is zero. \n\n\n\n\nThe problem  lies in the underlying infrastructure for analyzing and transforming C  source code. There are three reasons why it is hard to build such tools  for C. First, it is hard to handle multiple preprocessor configurations,  e.g., debug vs. release, Windows vs. Linux, x86 vs. x86 64, etc. Almost  all existing C program transformation tools present in IDEs work on a  single configuration of preprocessed code. This is inaccurate. For  example, a tool that applies a rename refactoring to a variable in one  configuration but ignores other configurations may change the behavior  of a program. Second, existing IDEs do not support sophisticated static  analyses on C source code, simultaneously handling all preprocessor  configurations. Third, no existing infrastructure handles multiple  programming languages, although modern programs often use more than one  language. Failure to cross the language boundary may make some program  transformations inaccurate. \n\n\n\n\n\n\n\n\n\n\nThe  PI proposed a program transformation infrastructure for C (named  OpenRefactory/C) that can handle these challenges. The research effort  has led to several innovations.\n\n \n\nA  parsing algorithm and program representation for handling multiple  preprocessor configurations. The language-agnostic parsing algorithm  allows any LALR(1) parser to parse code with multiple configurations and  represent programs in a single abstract syntax tree (AST).\nRepresentation  of semantic information (from static analyses) via directed edges  superimposed on the AST, but acknowledging the complications presented  by multiple configurations.\nA theoretical foundation for  verifying correctness of program transformations that considers  preservation of C code semantics and preprocessor semantics after the  transformation.\nA mechanism to test implemented refactorings by  applying them on real programs. This testing mechanism has been adopted  by Eclipse to test their implemented refactorings.\n\n\n \n\nThe  work has led to 6 research papers, a best research award at the ACM  Student Research Competition Grand Finals, a nomination for the ACM  Distinguished Paper Award, two other ACM Student Research awards, two  research demos, and several talks at academia and industry (UIUC,  Arizona State, Oregon State, Google Inc., Coverity, etc.,).\n\n\n\n\nIntellectual Merit. The  proposed work led to new algorithms and data structures needed to  implement scalable, robust automated program transformation tools for C.  It focused on the parts of this problem that have been inadequately  addressed in prior work&mdash; specifically, sound handling of the C  preprocessor and handling of mixed-language codes. The proposed research  addressed fundamental problems whose solutions would be essential for  researchers to investigate automated transformations for increasingly  complex software systems.\n\nBroader Impact. Successfully  addressing the limitations present in existing tools and providing a  robust program transformation infrastructure will allow researchers and  developers to explore novel automated transformations for C programs,  and to build tools to better address the complexities of real-world  software systems. The proposed method of handling multiple  configurations is completely general and will work, without  modification, even when the infrastructure is extended to handle C0x,  UPC, CUDA, and other C variants.  \n\n\n\n\n\n\n..."
 }
}