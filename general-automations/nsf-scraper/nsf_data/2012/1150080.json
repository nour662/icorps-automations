{
 "awd_id": "1150080",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER: Scheduling and Resource Allocation in the Cloud using Graphical Models and Randomized Algorithms",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2012-07-01",
 "awd_exp_date": "2017-06-30",
 "tot_intn_awd_amt": 447865.0,
 "awd_amount": 447865.0,
 "awd_min_amd_letter_date": "2012-06-28",
 "awd_max_amd_letter_date": "2016-08-09",
 "awd_abstract_narration": "Scalability is crucial for cloud computing to be widely adopted. Failure to scale has resulted in the demise of the social networking giant MySpace, the inability to support a user load greater than 10% of system capacity, a $4.5 billion annual power expenditure on data centers and a lack of any sophisticated measurement and monitoring systems in the cloud. The size of a cloud, which often consists of tens of thousands of machines, compels the use of low-complexity algorithms, which, when naively designed, cause significant performance degradation as the system grows large. Existing algorithms are often designed for exact, optimal solutions for smaller in-house systems and do not scale due to their centralized high-complexity nature.\r\n\r\nThis research overcomes the limitation of existing work by designing a suite of low-complexity algorithms for web services, data management, and measurement and monitoring in the cloud, which are exactly optimal only as the system size grows to infinity, but very close to optimal in finite and large systems. The algorithms are designed to address the challenges with dynamic scaling, multi-tenancy and data-intensiveness in the cloud, and for different application workloads including search, social networks and map-reduce. The research draws upon and contributes to the fields of graphical models and randomized algorithms, both of which exchange sparse information locally to achieve complex global objectives in large systems. The project also includes significant outreach programs in the form of workshops and lab open-houses, to promote undergraduate research, and the participation of women and under-represented minorities.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Yi",
   "pi_last_name": "Lu",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Yi Lu",
   "pi_email_addr": "yilu4@illinois.edu",
   "nsf_id": "000569767",
   "pi_start_date": "2012-06-28",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Illinois at Urbana-Champaign",
  "inst_street_address": "506 S WRIGHT ST",
  "inst_street_address_2": "",
  "inst_city_name": "URBANA",
  "inst_state_code": "IL",
  "inst_state_name": "Illinois",
  "inst_phone_num": "2173332187",
  "inst_zip_code": "618013620",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "IL13",
  "org_lgl_bus_name": "UNIVERSITY OF ILLINOIS",
  "org_prnt_uei_num": "V2PHZ2CSCH63",
  "org_uei_num": "Y8CWNJRCNN91"
 },
 "perf_inst": {
  "perf_inst_name": "University of Illinois at Urbana-Champaign",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "IL",
  "perf_st_name": "Illinois",
  "perf_zip_code": "618207473",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "IL13",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "1187",
   "pgm_ref_txt": "PECASE- eligible"
  },
  {
   "pgm_ref_code": "9102",
   "pgm_ref_txt": "WOMEN, MINORITY, DISABLED, NEC"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 85170.0
  },
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 176705.0
  },
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 185990.0
  },
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 0.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Data-parallel applications have become prevalent for processing large-scale data sets. A fundamental problem to all data-parallel applications is data locality, as the processing speed for data-processing tasks varies with data location. There are multiple levels of data locality, depending on whether the data block resides in local memory or disk, within a rack or a data center, or across data centers. Scheduling with data locality is an affinity scheduling problem, albeit with an explosive number of task types. Therefore, existing algorithms do not apply in this setting.</p>\n<p>For systems with two-level locality, our work show that a simple priority algorithm is delay-optimal in heavy-traffic regime. We find that going from two to three levels of locality changes the problem drastically, as a trade-off between performance and throughput emerges. With multi-level locality, we propose a novel algorithm that achieves delay optimality. This solves a version of an open problem in affinity scheduling, where we want to minimize delay without knowing job arrival rates. For both cases, the proof idea relies on the construction of an appropriate ideal load decomposition that allows the separate treatment of different subsystems, which future reveals an interesting state-space collapse. We implemented the algorithm in Hadoop clusters and demonstrated that it achieves an order of magnitude improvement over existing schedulers.</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/27/2017<br>\n\t\t\t\t\tModified by: Yi&nbsp;Lu</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nData-parallel applications have become prevalent for processing large-scale data sets. A fundamental problem to all data-parallel applications is data locality, as the processing speed for data-processing tasks varies with data location. There are multiple levels of data locality, depending on whether the data block resides in local memory or disk, within a rack or a data center, or across data centers. Scheduling with data locality is an affinity scheduling problem, albeit with an explosive number of task types. Therefore, existing algorithms do not apply in this setting.\n\nFor systems with two-level locality, our work show that a simple priority algorithm is delay-optimal in heavy-traffic regime. We find that going from two to three levels of locality changes the problem drastically, as a trade-off between performance and throughput emerges. With multi-level locality, we propose a novel algorithm that achieves delay optimality. This solves a version of an open problem in affinity scheduling, where we want to minimize delay without knowing job arrival rates. For both cases, the proof idea relies on the construction of an appropriate ideal load decomposition that allows the separate treatment of different subsystems, which future reveals an interesting state-space collapse. We implemented the algorithm in Hadoop clusters and demonstrated that it achieves an order of magnitude improvement over existing schedulers.\n\n \n\n\t\t\t\t\tLast Modified: 07/27/2017\n\n\t\t\t\t\tSubmitted by: Yi Lu"
 }
}