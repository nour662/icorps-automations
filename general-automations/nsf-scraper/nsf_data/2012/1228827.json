{
 "awd_id": "1228827",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "TWC: Medium: Collaborative: Breaking the Satisfiability Modulo Theories (SMT) Bottleneck in Symbolic Security Analysis",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2012-09-01",
 "awd_exp_date": "2017-08-31",
 "tot_intn_awd_amt": 391983.0,
 "awd_amount": 391983.0,
 "awd_min_amd_letter_date": "2012-08-14",
 "awd_max_amd_letter_date": "2012-08-14",
 "awd_abstract_narration": "The security of our software is critical for consumer confidence, the protection of privacy and valuable intellectual property, and of course national security. Because of our society's increased reliance on software, security breaches can lead to serious personal or corporate losses, and endanger the privacy, liberties, and even the lives of individuals. As threats to software security have become more sophisticated, so too have the techniques and analyses developed to improve it. Symbolic execution has emerged as a fundamental tool for security applications. Its main idea is to run a program using symbolic instead of concrete values: a set of symbols are assigned to the program inputs, and the outputs are expressed as a set of \"verification conditions\", logical formulas over the input symbols.  A number of successful security analyses use symbolic execution and similar methods to recast security questions about programs as constraint satisfaction problems in some formal logic. Automatic reasoners for that logic can then be used to solve those problems.  In the last few years, solvers based on Satisfiability Modulo Theories (SMT) techniques have become a natural choice in such approaches to security because of their superior performance and automation compared to more traditional theorem provers and their greater generality with respect to ad-hoc tools or propositional satisfiability solvers.\r\n\r\nThis collaborative project brings together experts in security and in SMT to pursue two complementary research goals: (i) harness the full power of SMT solvers to improve current security tools based on symbolic analysis; and (ii) design and develop new techniques to address the needs of anticipated future security applications. Specific activities addressing these goals include: collecting challenge benchmark problems from existing security analyses and developing targeted SMT optimizations for these benchmarks; developing appropriate security abstractions in the SMT language used to express security verification conditions; developing logical theories and algorithms for reasoning about character strings in such verification conditions; exposing a general framework for extending the verification condition language; and developing techniques for computing symbolic solution sets for SMT constraints. These activities are expected to (i) significantly increase the flexibility, performance, and reasoning capabilities of SMT solvers in support of security applications; (ii) improve the performance and scalability of current security analyses by leveraging the reasoning power of SMT solvers; and (iii) provide a foundation for new, more powerful, and more expressive security analyses. Overall, this project will help create more scalable and expressive security applications which could have a considerable impact on society as they enable the production of software much more resistant to security attacks.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "David",
   "pi_last_name": "Brumley",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "David Brumley",
   "pi_email_addr": "dbrumley@cmu.edu",
   "nsf_id": "000528461",
   "pi_start_date": "2012-08-14",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Shan Leung",
   "pi_last_name": "Woo",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Shan Leung Woo",
   "pi_email_addr": "maverick@cs.cmu.edu",
   "nsf_id": "000614424",
   "pi_start_date": "2012-08-14",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Carnegie-Mellon University",
  "inst_street_address": "5000 FORBES AVE",
  "inst_street_address_2": "",
  "inst_city_name": "PITTSBURGH",
  "inst_state_code": "PA",
  "inst_state_name": "Pennsylvania",
  "inst_phone_num": "4122688746",
  "inst_zip_code": "152133815",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "PA12",
  "org_lgl_bus_name": "CARNEGIE MELLON UNIVERSITY",
  "org_prnt_uei_num": "U3NKNFLNQ613",
  "org_uei_num": "U3NKNFLNQ613"
 },
 "perf_inst": {
  "perf_inst_name": "Carnegie-Mellon University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "PA",
  "perf_st_name": "Pennsylvania",
  "perf_zip_code": "152133890",
  "perf_ctry_code": "US",
  "perf_cong_dist": "12",
  "perf_st_cong_dist": "PA12",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7434",
   "pgm_ref_txt": "CNCI"
  },
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 391983.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span id=\"docs-internal-guid-eec6a692-b896-fffd-e999-42e6fe48242e\">\n<p dir=\"ltr\"><span>The security of our software is critical for consumer confidence, protection of privacy, protection of valuable intellectual property, and national security. As threats to software security have become more sophisticated, so too have the techniques developed to ensure security. A fundamental technique is symbolic execution which enables several security analyses such as automatic exploit generation, malware analysis, and input filtering. In this technique, a program is executed with symbolic instead of concrete inputs, making it is possible to analyze many different program executions at the same time by using as reasoning backend a solver for symbolic constraints. Backend solvers based on Satisfiability Modulo Theories (SMT) methods are a natural choice in symbolic execution-based approaches to security because of: (i) their superior performance and automation compared to more traditional solvers; and (ii) their greater generality with respect to ad-hoc tools and propositional solvers.</span></p>\n<br />\n<p dir=\"ltr\"><span>In this project, we developed several new or improved subsolvers for SMT that are useful for security analyses, such as one for the theory of strings, and integrated them in the open-source SMT solver CVC4. In parallel with that, we developed and implemented a novel symbolic execution technique that leverages these new capabilities. The technique, which we dubbed Veritesting, increases the scalability of (dynamic) symbolic execution by combining it with (static) program verification. Its main idea is to verify only selected parts of a program and do so only in a specific dynamic context, the one currently being symbolically executed. This results in a dramatic reduction in the number of the generated constraints for the SMT solver with respect to traditional symbolic execution, which in turn yields a significant improvement in its scalability. Veritesting enabled during this project the discovery of over a thousand of security bugs in widely used Linux programs, which we reported to the Linux community. Additionally, we investigated the use of symbolic execution for the analysis of Python programs, with a focus on exploiting to the new string reasoning capabilities of CVC4. Building on previous work by others, we developed PyEx, an open-source symbolic execution tool with increased robustness and test coverage, and used it to study the discovery of security vulnerability in open source Python code, much of which includes string operations.</span></p>\n<br />\n<p dir=\"ltr\"><span>Of the new subsolvers for CVC4, the first specializes on the theory of bitvectors. This theory is at the heart of most program analyses as it can be used to reason about binary code at the level of machine operations. Our new solver combines two approaches (called lazy and eager) to achieve maximum performance. The implementation in CVC4 has ranked near the top in the annual SMT solver competitions for the last few years and is being used in security applications in industry (for example, at Google). The second subsolver is for a rich theory of character strings. String manipulation is at the heart of several high-profile security attacks, including SQL injection and cross-site scripting attacks. The subsolver can be used to automatically reason about code that might be vulnerable to such attacks. Thanks to it, CVC4 can solve a very large majority (&gt; 93%) of benchmarks in a large suite consisting of problems generated from PyEx and other security tools. Finally, we developed a theory solver for finite sets with cardinality constraints and extended it to reason about finite relations as well. Sets and relations are a key mathematical building block in many abstractions and reasoning systems. By providing a native theory solver for them that can be combined with other theories (including bitvectors and strings), we made it is possible to model and reason about a wide variety of operations and abstractions.</span></p>\n<p dir=\"ltr\"><span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span> </span></p>\n<p dir=\"ltr\"><span>CVC4, which is available online at </span><a href=\"http://cvc4.cs.stanford.edu/web/\"><span>http://cvc4.cs.stanford.edu</span></a><span>, is being used in a large number of academic and industrial projects and applications, including security applications. The new capabilities developed in this project will directly benefit those efforts.</span></p>\n<div><span><br /></span></div>\n</span></p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 01/02/2018<br>\n\t\t\t\t\tModified by: David&nbsp;Brumley</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n\nThe security of our software is critical for consumer confidence, protection of privacy, protection of valuable intellectual property, and national security. As threats to software security have become more sophisticated, so too have the techniques developed to ensure security. A fundamental technique is symbolic execution which enables several security analyses such as automatic exploit generation, malware analysis, and input filtering. In this technique, a program is executed with symbolic instead of concrete inputs, making it is possible to analyze many different program executions at the same time by using as reasoning backend a solver for symbolic constraints. Backend solvers based on Satisfiability Modulo Theories (SMT) methods are a natural choice in symbolic execution-based approaches to security because of: (i) their superior performance and automation compared to more traditional solvers; and (ii) their greater generality with respect to ad-hoc tools and propositional solvers.\n\n\nIn this project, we developed several new or improved subsolvers for SMT that are useful for security analyses, such as one for the theory of strings, and integrated them in the open-source SMT solver CVC4. In parallel with that, we developed and implemented a novel symbolic execution technique that leverages these new capabilities. The technique, which we dubbed Veritesting, increases the scalability of (dynamic) symbolic execution by combining it with (static) program verification. Its main idea is to verify only selected parts of a program and do so only in a specific dynamic context, the one currently being symbolically executed. This results in a dramatic reduction in the number of the generated constraints for the SMT solver with respect to traditional symbolic execution, which in turn yields a significant improvement in its scalability. Veritesting enabled during this project the discovery of over a thousand of security bugs in widely used Linux programs, which we reported to the Linux community. Additionally, we investigated the use of symbolic execution for the analysis of Python programs, with a focus on exploiting to the new string reasoning capabilities of CVC4. Building on previous work by others, we developed PyEx, an open-source symbolic execution tool with increased robustness and test coverage, and used it to study the discovery of security vulnerability in open source Python code, much of which includes string operations.\n\n\nOf the new subsolvers for CVC4, the first specializes on the theory of bitvectors. This theory is at the heart of most program analyses as it can be used to reason about binary code at the level of machine operations. Our new solver combines two approaches (called lazy and eager) to achieve maximum performance. The implementation in CVC4 has ranked near the top in the annual SMT solver competitions for the last few years and is being used in security applications in industry (for example, at Google). The second subsolver is for a rich theory of character strings. String manipulation is at the heart of several high-profile security attacks, including SQL injection and cross-site scripting attacks. The subsolver can be used to automatically reason about code that might be vulnerable to such attacks. Thanks to it, CVC4 can solve a very large majority (&gt; 93%) of benchmarks in a large suite consisting of problems generated from PyEx and other security tools. Finally, we developed a theory solver for finite sets with cardinality constraints and extended it to reason about finite relations as well. Sets and relations are a key mathematical building block in many abstractions and reasoning systems. By providing a native theory solver for them that can be combined with other theories (including bitvectors and strings), we made it is possible to model and reason about a wide variety of operations and abstractions.\n                     \nCVC4, which is available online at http://cvc4.cs.stanford.edu, is being used in a large number of academic and industrial projects and applications, including security applications. The new capabilities developed in this project will directly benefit those efforts.\n\n\n\n\n \n\n\t\t\t\t\tLast Modified: 01/02/2018\n\n\t\t\t\t\tSubmitted by: David Brumley"
 }
}