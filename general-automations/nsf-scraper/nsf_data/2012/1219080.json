{
 "awd_id": "1219080",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CSR:  Small:  Automated Software Fault Localization via Static and Dynamic Analysis",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2012-09-01",
 "awd_exp_date": "2016-05-31",
 "tot_intn_awd_amt": 490001.0,
 "awd_amount": 490001.0,
 "awd_min_amd_letter_date": "2012-08-24",
 "awd_max_amd_letter_date": "2012-08-24",
 "awd_abstract_narration": "This project aims to improve tool support for software debugging, by providing automatic assistance in the identification of root causes of a software failure using static and dynamic program analysis techniques. A flexible diagnosis framework first identifies candidate root causes of a failure and then uses a broad, open-ended series of diagnosic \"filters\" to narrow down the most likely root causes. A key innovation is that the system automatically generates \"passing\" and \"failing\" inputs for diagnosis that are close to the original failing input, making it less likely that root causes are missed.  The work develops two approaches for this difficult step, based on concolic testing and on string rewriting using the application's input grammar, and investigates various types of program properties (\"likely invariants\") for effective localization of various classes of bugs. Candidates are then winnowed using novel filters based on existing and new program analyses to pinpoint root causes with few false positives.\r\n\r\nThis research will significantly increase programmer productivity by reducing manual debugging effort and improve reliability and security by reducing the time to fix critical software failures. A fully-automated diagnosis tool based on the widely-used LLVM compiler will be publicly distributed for developers to use. It will also be used for teaching debugging techniques and program analysis techniques in university classes.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Vikram",
   "pi_last_name": "Adve",
   "pi_mid_init": "S",
   "pi_sufx_name": "",
   "pi_full_name": "Vikram S Adve",
   "pi_email_addr": "vadve@cs.uiuc.edu",
   "nsf_id": "000334755",
   "pi_start_date": "2012-08-24",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Illinois at Urbana-Champaign",
  "inst_street_address": "506 S WRIGHT ST",
  "inst_street_address_2": "",
  "inst_city_name": "URBANA",
  "inst_state_code": "IL",
  "inst_state_name": "Illinois",
  "inst_phone_num": "2173332187",
  "inst_zip_code": "618013620",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "IL13",
  "org_lgl_bus_name": "UNIVERSITY OF ILLINOIS",
  "org_prnt_uei_num": "V2PHZ2CSCH63",
  "org_uei_num": "Y8CWNJRCNN91"
 },
 "perf_inst": {
  "perf_inst_name": "University of Illinois at Urbana-Champaign",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "IL",
  "perf_st_name": "Illinois",
  "perf_zip_code": "618207473",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "IL13",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7354",
   "pgm_ref_txt": "COMPUTER SYSTEMS"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 490001.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span id=\"docs-internal-guid-05051271-bd8f-690b-cf84-a3e9ea1f0ef7\"> </span></p>\n<p dir=\"ltr\"><span>Software failures cost the US economy hundreds of billions of dollars in lost productivity and economic disruption every year, and greatly detract from consumer satisfaction with many modern products and services. Worse still, diagnosing and repairing software failures is a tedious, labor-intensive and time-consuming process.</span></p>\n<p dir=\"ltr\"><span>In our research, we have automated one key step in this process, namely, diagnosing the root causes of software failures. &nbsp;Moreover, the information gathered in our approach can greatly assist programmers in understanding and repairing the failures. &nbsp;Even for a failure of a large program with millions of lines of code, our approach can automatically narrow down a few candidate locations </span><span>where</span><span> the root cause (the &ldquo;bug&rdquo;) might be found, and extract information showing how each of those possible bugs may lead to the visible symptoms of the failure. &nbsp;This approach requires only a small amount of one-time preparation by the developers of the software, and is otherwise fully automatic after each failure, greatly reducing the manual effort needed to do the diagnosis.</span></p>\n<p dir=\"ltr\"><span>In subsequent work, we have explored more sophisticated techniques called dynamic symbolic execution (DSE) that can help further reduce the number of possible candidates root causes identified by our approach. &nbsp;Our initial experiments found that the state of the art of DSE was too inefficient to be applied to realistic programs for the purposes we required, namely, exploring specific execution histories for a failure with known symptoms. &nbsp;We studied existing techniques carefully, identified two broad classes of techniques for DSE, which we labeled </span><span>Solution-agnostic Symbolic Execution</span><span> and </span><span>Solution-driven Symbolic Execution</span><span>, and showed that there are fundamental tradeoffs between these two classes of techniques. We developed a new class of techniques we call </span><span>Solution-aware Symbolic Execution</span><span>, which aims to combine the advantages of both classes while minimizing their disadvantages. &nbsp;We extended a widely used system called KLEE to support and enable experimentation with all three classes of techniques in a common system. &nbsp;Our experimental comparisons of these three classes (with several programs) have been inconclusive, however: the new approach is sometimes better and sometimes worse than the previous approaches, without any one dominating the others. &nbsp;Nevertheless, the new approach provides a new class of strategies that had not been explored before.</span></p>\n<p dir=\"ltr\"><span><br /></span></p>\n<div><span><br /></span></div>\n<p>&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 06/18/2017<br>\n\t\t\t\t\tModified by: Vikram&nbsp;S&nbsp;Adve</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n \nSoftware failures cost the US economy hundreds of billions of dollars in lost productivity and economic disruption every year, and greatly detract from consumer satisfaction with many modern products and services. Worse still, diagnosing and repairing software failures is a tedious, labor-intensive and time-consuming process.\nIn our research, we have automated one key step in this process, namely, diagnosing the root causes of software failures.  Moreover, the information gathered in our approach can greatly assist programmers in understanding and repairing the failures.  Even for a failure of a large program with millions of lines of code, our approach can automatically narrow down a few candidate locations where the root cause (the \"bug\") might be found, and extract information showing how each of those possible bugs may lead to the visible symptoms of the failure.  This approach requires only a small amount of one-time preparation by the developers of the software, and is otherwise fully automatic after each failure, greatly reducing the manual effort needed to do the diagnosis.\nIn subsequent work, we have explored more sophisticated techniques called dynamic symbolic execution (DSE) that can help further reduce the number of possible candidates root causes identified by our approach.  Our initial experiments found that the state of the art of DSE was too inefficient to be applied to realistic programs for the purposes we required, namely, exploring specific execution histories for a failure with known symptoms.  We studied existing techniques carefully, identified two broad classes of techniques for DSE, which we labeled Solution-agnostic Symbolic Execution and Solution-driven Symbolic Execution, and showed that there are fundamental tradeoffs between these two classes of techniques. We developed a new class of techniques we call Solution-aware Symbolic Execution, which aims to combine the advantages of both classes while minimizing their disadvantages.  We extended a widely used system called KLEE to support and enable experimentation with all three classes of techniques in a common system.  Our experimental comparisons of these three classes (with several programs) have been inconclusive, however: the new approach is sometimes better and sometimes worse than the previous approaches, without any one dominating the others.  Nevertheless, the new approach provides a new class of strategies that had not been explored before.\n\n\n\n\n\n \n\n \n\n\t\t\t\t\tLast Modified: 06/18/2017\n\n\t\t\t\t\tSubmitted by: Vikram S Adve"
 }
}