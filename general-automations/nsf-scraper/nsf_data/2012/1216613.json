{
 "awd_id": "1216613",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Programming with Non-Coherent Memory",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2012-09-01",
 "awd_exp_date": "2017-08-31",
 "tot_intn_awd_amt": 450000.0,
 "awd_amount": 450000.0,
 "awd_min_amd_letter_date": "2012-06-25",
 "awd_max_amd_letter_date": "2016-11-22",
 "awd_abstract_narration": "The preponderance of language design and program analysis efforts in the study of multicore systems has implicitly assumed the presence of an underlying coherent memory that ensures global visibility of updates performed on processor-local caches.  Because all threads witness a consistent view of data, concurrency bugs manifest purely as a consequence of unintended non-determinism introduced by scheduler-driven thread interleavings and inadequate synchronization.  As new architectural advances lead to multicore or manycore platforms supporting hundreds of (potentially heterogenous) cores, automatically enforcing memory coherence becomes an increasingly complex and expensive proposition.  Indeed, new architectural designs are likely to sacrifice local coherence guarantees in exchange for a simple commodity-based scalable design, equipped with a limited degree of global shared memory.  Applications that target such platforms must be carefully written not to make assumptions about the consistency of the contents of memory locations accessed and modified locally.  In the absence of coherence, new techniques are needed to recover the abstraction benefits that are now lost; these issues become exacerbated at scale.  The broader impacts of the proposal have obvious positive interaction with industry efforts to promote multicore and manycore processor platforms.\r\n\r\nThis project will consider novel ways to map consistency models expressed in the context of high-level managed languages onto non-coherent architectural platforms.  In doing so, it will consider new programming models, abstractions, analyses, and implementations to enable (a) avoidance of coherency enforcement whenever possible, (b) reduction of coherency demands based on application logic, (c) specification of complex consistency requirements that can be used to inform the implementation of specialized software-based coherence protocols, and (d) integration of language-level memory models with weakly-coherent architectures.  The project will subsume formal, rigorous development of different abstractions, analyses, and implementations that enable the automatic construction of new protocol families that express complex aggregates of communication and computation actions with sensible consistency semantics even when executed on non-coherent platforms.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Sunil",
   "pi_last_name": "Prabhakar",
   "pi_mid_init": "K",
   "pi_sufx_name": "",
   "pi_full_name": "Sunil K Prabhakar",
   "pi_email_addr": "sunil@purdue.edu",
   "nsf_id": "000490800",
   "pi_start_date": "2015-09-14",
   "pi_end_date": "2016-11-22"
  },
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Suresh",
   "pi_last_name": "Jagannathan",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Suresh Jagannathan",
   "pi_email_addr": "suresh@cs.purdue.edu",
   "nsf_id": "000181308",
   "pi_start_date": "2016-11-22",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Gustavo",
   "pi_last_name": "Petri",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Gustavo Petri",
   "pi_email_addr": "gpetri@purdue.edu",
   "nsf_id": "000653846",
   "pi_start_date": "2013-09-30",
   "pi_end_date": "2015-09-14"
  }
 ],
 "inst": {
  "inst_name": "Purdue University",
  "inst_street_address": "2550 NORTHWESTERN AVE # 1100",
  "inst_street_address_2": "",
  "inst_city_name": "WEST LAFAYETTE",
  "inst_state_code": "IN",
  "inst_state_name": "Indiana",
  "inst_phone_num": "7654941055",
  "inst_zip_code": "479061332",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "IN04",
  "org_lgl_bus_name": "PURDUE UNIVERSITY",
  "org_prnt_uei_num": "YRXVL4JYCEF5",
  "org_uei_num": "YRXVL4JYCEF5"
 },
 "perf_inst": {
  "perf_inst_name": "Purdue University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "IN",
  "perf_st_name": "Indiana",
  "perf_zip_code": "479062017",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "IN04",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 450000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The evolution from single-core to multi- and many-core architectures has led to new programming models and abstractions for concurrent programming.&nbsp; To reason about the behavior and correctness of applications executing in such environments, program analyses and runtime monitors have been able to safely assume the availability of an underlying coherent memory that ensures global visibility of updates performed on processor-local caches.&nbsp; Because all threads witness a consistent view of data, concurrency bugs manifest purely because of unintended non-determinism introduced by scheduler-driven thread interleavings and inadequate synchronization.</p>\n<p>Scaling demands, however, have led to new architectural designs supporting hundreds of potentially heterogeneous cores that make coherence enforcement an increasingly expensive and complex proposition.&nbsp; These architectures more closely resemble loosely-coupled distributed systems which typically offer few coherency guarantees.&nbsp; While there is no clear consensus on how these systems will ultimately evolve, &nbsp;the benefits to scalability, power, and simplicity suggest that designs without system-wide hardware coherence support are likely to become more common.&nbsp; The emergence of such systems requires a radical rethinking of the entire software stack, from the operating system and kernel design to application-level semantics, programming abstractions, and models.&nbsp; It is an investigation of these ideas that forms the central focus of this proposal.</p>\n<p>Applications that target such platforms must be carefully written not to make assumptions about the global consistency of the contents of cache locations accessed and modified locally.&nbsp; In the absence of coherence support, new techniques are needed to recover the abstraction benefits that are now lost.</p>\n<p>This project has considered new ways to map consistency models expressed in the context of high-level managed languages onto non-coherent concurrent and distributed platforms.&nbsp; In doing we have explored new programming models, abstractions, analyses, and implementations to enable (a)&nbsp; avoidance of coherency enforcement whenever possible, (b) reduction of coherency demands based on application logic, (c) specification of complex consistency requirements that can be used to inform the implementation of specialized software-based coherence protocols, and (d) integration of language-level memory models with weakly-coherent architectures.<br /><br /><br />&nbsp;<br /><br /><br /></p><br>\n<p>\n\t\t\t\t      \tLast Modified: 03/12/2018<br>\n\t\t\t\t\tModified by: Suresh&nbsp;Jagannathan</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe evolution from single-core to multi- and many-core architectures has led to new programming models and abstractions for concurrent programming.  To reason about the behavior and correctness of applications executing in such environments, program analyses and runtime monitors have been able to safely assume the availability of an underlying coherent memory that ensures global visibility of updates performed on processor-local caches.  Because all threads witness a consistent view of data, concurrency bugs manifest purely because of unintended non-determinism introduced by scheduler-driven thread interleavings and inadequate synchronization.\n\nScaling demands, however, have led to new architectural designs supporting hundreds of potentially heterogeneous cores that make coherence enforcement an increasingly expensive and complex proposition.  These architectures more closely resemble loosely-coupled distributed systems which typically offer few coherency guarantees.  While there is no clear consensus on how these systems will ultimately evolve,  the benefits to scalability, power, and simplicity suggest that designs without system-wide hardware coherence support are likely to become more common.  The emergence of such systems requires a radical rethinking of the entire software stack, from the operating system and kernel design to application-level semantics, programming abstractions, and models.  It is an investigation of these ideas that forms the central focus of this proposal.\n\nApplications that target such platforms must be carefully written not to make assumptions about the global consistency of the contents of cache locations accessed and modified locally.  In the absence of coherence support, new techniques are needed to recover the abstraction benefits that are now lost.\n\nThis project has considered new ways to map consistency models expressed in the context of high-level managed languages onto non-coherent concurrent and distributed platforms.  In doing we have explored new programming models, abstractions, analyses, and implementations to enable (a)  avoidance of coherency enforcement whenever possible, (b) reduction of coherency demands based on application logic, (c) specification of complex consistency requirements that can be used to inform the implementation of specialized software-based coherence protocols, and (d) integration of language-level memory models with weakly-coherent architectures.\n\n\n \n\n\n\n\n\t\t\t\t\tLast Modified: 03/12/2018\n\n\t\t\t\t\tSubmitted by: Suresh Jagannathan"
 }
}