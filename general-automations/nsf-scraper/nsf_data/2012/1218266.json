{
 "awd_id": "1218266",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Collaborative Research: Tracing and Reasoning about Changing Artifacts",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2012-09-01",
 "awd_exp_date": "2017-08-31",
 "tot_intn_awd_amt": 490580.0,
 "awd_amount": 504980.0,
 "awd_min_amd_letter_date": "2012-08-29",
 "awd_max_amd_letter_date": "2017-01-30",
 "awd_abstract_narration": "Change pervades the entire software development process. Software may be changed in response to market forces, changing customer requirements, or new hardware and software dependencies. The thread of changes, along with the decisions behind those changes, is often transient and is rarely directly captured by a development team.  Source code drifts away from requirement and design documents (and other artifacts) that explain the motivations and decisions behind the code. There is a high overhead in maintaining consistency between these artifacts and the code. Project schedules have tight deadlines, with little or no time to explicitly document the decisions behind code changes. Thus, further code modifications are often expensive because the software engineers lack the understanding of past decisions.\r\n\r\nThis project aims to investigate a lightweight, flexible, and systematic approach to identifying and connecting related changes to support future maintenance activities. By leveraging traceability and refactoring techniques, we can represent change as a first-class artifact so that software engineers can better understand the nature of change and how it impacts related artifacts. Our approach is novel because it allows developers to reason about changes as varied as high-level concepts to low-level code that cuts across several modules. We also investigate techniques for bridging any gaps between these connections.\r\n\r\nThe approach is applicable to organizations that maintain legacy systems or acquire software from other organizations. The results will also be valuable to any medium- or large-scale development context in assimilating new personnel and in coordinating distributed development.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Hazeline",
   "pi_last_name": "Asuncion",
   "pi_mid_init": "U",
   "pi_sufx_name": "",
   "pi_full_name": "Hazeline U Asuncion",
   "pi_email_addr": "hazeline@u.washington.edu",
   "nsf_id": "000573395",
   "pi_start_date": "2012-08-29",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Washington",
  "inst_street_address": "4333 BROOKLYN AVE NE",
  "inst_street_address_2": "",
  "inst_city_name": "SEATTLE",
  "inst_state_code": "WA",
  "inst_state_name": "Washington",
  "inst_phone_num": "2065434043",
  "inst_zip_code": "981951016",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "WA07",
  "org_lgl_bus_name": "UNIVERSITY OF WASHINGTON",
  "org_prnt_uei_num": "",
  "org_uei_num": "HD1WMN6945W6"
 },
 "perf_inst": {
  "perf_inst_name": "University of Washington Bothell",
  "perf_str_addr": "18115 Campus Way NE",
  "perf_city_name": "Bothell",
  "perf_st_code": "WA",
  "perf_st_name": "Washington",
  "perf_zip_code": "980118246",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "WA01",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794400",
   "pgm_ele_name": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 490580.0
  },
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 14400.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><strong><em>Intellectual Merit: </em></strong>Flexible Artifact Change and Traceability Support (FACTS) investigates how related changes can be explicitly connected in order to support future software maintenance activities. The thread of changes, along with the decisions behind those changes, is often transient.&nbsp; Even when the reasons are recorded, they are rarely explicitly connected to code changes.&nbsp; Code drifts from artifacts that explain the decisions behind the code&mdash;artifacts such as requirements, use cases, or design documents. Maintaining consistency between these artifacts and the code requires high overhead, because it is difficult to determine which requirements or design elements are out of date. Project schedules also run with tight deadlines so there is little or no time to explicitly document the decisions behind source code changes. Thus, further code modifications are often expensive because the maintenance engineers lack the understanding of past decisions and the original developers may no longer be working with the organization. Effective change management will allow questions such as the following to be answered: &ldquo;What technical decisions prompted the changes in the code?&rdquo; or &ldquo;What is the rationale behind the change in design?&rdquo;</p>\n<p>Tracing source code changes to their reasons presents several technical challenges.&nbsp; First, source code changes can be expressed at different levels of granularity (e.g., line, method, class, package, behavior, refactored changes).&nbsp; Second, reasons can be heterogeneously represented and may be scattered across different tools (e.g., repositories, databases, flat files).&nbsp; Third, connecting code changes to reasons require traceability at different levels of abstraction.&nbsp; For example, a feature &ldquo;elastic scalability&rdquo; may have no matching terms in the source code, and thus, may be difficult to connect to source code changes.</p>\n<p>To address the first challenge, we extract code changes at different levels of granularity and uniformly represent them as Code Change Descriptions (CCDs).&nbsp; To perform the extraction, we leverage existing software evolution tools to extract code changes at the line, method, or refactored level.&nbsp; Once these code changes are extracted, we then uniformly represent them as CCDs to enable us to generate traceability links between related CCDs.</p>\n<p>To address the second challenge, we use different artifact extractors.&nbsp; We used keywords such as &ldquo;history&rdquo; or &ldquo;change notes&rdquo; to identify embedded reasons within artifacts.&nbsp; We also leverage the APIs of various tools to extract explicitly stored reasons (e.g., reasons stored as issues or bugs in a database). The process of extraction is tool-specific and artifact-specific (e.g., the process of extracting an issue and changes notes may be different even though both may be extracted from web pages).&nbsp;&nbsp; We built an extractor for each tool and artifact type.&nbsp; Once the reasons are extracted, they are uniformly represented as Artifact Change Descriptions (ACDs)</p>\n<p>Creating traceability links across different levels of abstraction is perhaps the most difficult of the three challenges. &nbsp;Thus, we examined two different ways to tackle this challenge: centering traceability links on the commit records and architecture.</p>\n<p>Centering traceability links on commit records work well in contexts where a version control system is used and developers enter meaningful commit descriptions for each commit.&nbsp; In this technique, the commit description is an ACD, and we use this commit ACD as a bridge between code changes and explanation.&nbsp; The connection between the commit ACD and code changes are already provided by a version control system.&nbsp; Traceability links between the commit ACD and the other ACDs are generated using a classifier (Random Forest).&nbsp; We also use features that analyze text similarity and adds more weight to important terms.&nbsp; Traceability links between CCDs and other CCDs are generated by matching fully qualified paths.</p>\n<p>Centering traceability links on the architecture work well in contexts where one needs to track feature changes to source code changes.&nbsp; In a related project, xLineMapper, we bridge these different levels of abstraction by integrating features specification into a product line architecture model.&nbsp; &nbsp;We also use an architecture-implementation mapping that combines code generation with annotation processing. &nbsp;Thus, when either the feature or architecture changes, these changes cascade to the source code.</p>\n<p>This project not only yielded novel techniques in tracing code to reasons behind changes, it also provided the following novel techniques: discovery of related source code files (FP-LDA), automated collection of software metrics via change entries (FACTS PT), and data-centric traceability in source code (DDC Tracer).&nbsp; We also investigated tracking source code changes, along with changes to other simulation-related data, in the context of computational neuroscience research (BrainGrid project).</p>\n<p><strong><em>Broader Impacts: </em></strong>FACTS technique can assist domain scientists in understanding software changes performed by their students and colleagues.&nbsp; This project can lower software development and maintenance costs, enabling the production of more affordable and quality software.&nbsp; We have started this investigation with the BrainGrid project.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/30/2017<br>\n\t\t\t\t\tModified by: Hazeline&nbsp;U&nbsp;Asuncion</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nIntellectual Merit: Flexible Artifact Change and Traceability Support (FACTS) investigates how related changes can be explicitly connected in order to support future software maintenance activities. The thread of changes, along with the decisions behind those changes, is often transient.  Even when the reasons are recorded, they are rarely explicitly connected to code changes.  Code drifts from artifacts that explain the decisions behind the code&mdash;artifacts such as requirements, use cases, or design documents. Maintaining consistency between these artifacts and the code requires high overhead, because it is difficult to determine which requirements or design elements are out of date. Project schedules also run with tight deadlines so there is little or no time to explicitly document the decisions behind source code changes. Thus, further code modifications are often expensive because the maintenance engineers lack the understanding of past decisions and the original developers may no longer be working with the organization. Effective change management will allow questions such as the following to be answered: \"What technical decisions prompted the changes in the code?\" or \"What is the rationale behind the change in design?\"\n\nTracing source code changes to their reasons presents several technical challenges.  First, source code changes can be expressed at different levels of granularity (e.g., line, method, class, package, behavior, refactored changes).  Second, reasons can be heterogeneously represented and may be scattered across different tools (e.g., repositories, databases, flat files).  Third, connecting code changes to reasons require traceability at different levels of abstraction.  For example, a feature \"elastic scalability\" may have no matching terms in the source code, and thus, may be difficult to connect to source code changes.\n\nTo address the first challenge, we extract code changes at different levels of granularity and uniformly represent them as Code Change Descriptions (CCDs).  To perform the extraction, we leverage existing software evolution tools to extract code changes at the line, method, or refactored level.  Once these code changes are extracted, we then uniformly represent them as CCDs to enable us to generate traceability links between related CCDs.\n\nTo address the second challenge, we use different artifact extractors.  We used keywords such as \"history\" or \"change notes\" to identify embedded reasons within artifacts.  We also leverage the APIs of various tools to extract explicitly stored reasons (e.g., reasons stored as issues or bugs in a database). The process of extraction is tool-specific and artifact-specific (e.g., the process of extracting an issue and changes notes may be different even though both may be extracted from web pages).   We built an extractor for each tool and artifact type.  Once the reasons are extracted, they are uniformly represented as Artifact Change Descriptions (ACDs)\n\nCreating traceability links across different levels of abstraction is perhaps the most difficult of the three challenges.  Thus, we examined two different ways to tackle this challenge: centering traceability links on the commit records and architecture.\n\nCentering traceability links on commit records work well in contexts where a version control system is used and developers enter meaningful commit descriptions for each commit.  In this technique, the commit description is an ACD, and we use this commit ACD as a bridge between code changes and explanation.  The connection between the commit ACD and code changes are already provided by a version control system.  Traceability links between the commit ACD and the other ACDs are generated using a classifier (Random Forest).  We also use features that analyze text similarity and adds more weight to important terms.  Traceability links between CCDs and other CCDs are generated by matching fully qualified paths.\n\nCentering traceability links on the architecture work well in contexts where one needs to track feature changes to source code changes.  In a related project, xLineMapper, we bridge these different levels of abstraction by integrating features specification into a product line architecture model.   We also use an architecture-implementation mapping that combines code generation with annotation processing.  Thus, when either the feature or architecture changes, these changes cascade to the source code.\n\nThis project not only yielded novel techniques in tracing code to reasons behind changes, it also provided the following novel techniques: discovery of related source code files (FP-LDA), automated collection of software metrics via change entries (FACTS PT), and data-centric traceability in source code (DDC Tracer).  We also investigated tracking source code changes, along with changes to other simulation-related data, in the context of computational neuroscience research (BrainGrid project).\n\nBroader Impacts: FACTS technique can assist domain scientists in understanding software changes performed by their students and colleagues.  This project can lower software development and maintenance costs, enabling the production of more affordable and quality software.  We have started this investigation with the BrainGrid project.\n\n\t\t\t\t\tLast Modified: 11/30/2017\n\n\t\t\t\t\tSubmitted by: Hazeline U Asuncion"
 }
}