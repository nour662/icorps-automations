{
 "awd_id": "1250702",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "EAGER: Automatic Classification of Programming Difficulties by Mining Programming Events",
 "cfda_num": "47.070",
 "org_code": "05020000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "William Bainbridge",
 "awd_eff_date": "2012-09-01",
 "awd_exp_date": "2015-08-31",
 "tot_intn_awd_amt": 100000.0,
 "awd_amount": 124960.0,
 "awd_min_amd_letter_date": "2012-08-25",
 "awd_max_amd_letter_date": "2014-04-25",
 "awd_abstract_narration": "Today, when a student or industrial programmer faces difficulty in some task assigned to him/her, this event often goes unrecorded and unobserved by others. As a result, it is not possible to use mechanisms to ameliorate the effect of the difficulty. In this project, the researchers will address this problem by automatically detecting and classifying programming difficulties by mining programmers' interaction with the computer.  Specifically, they will investigate (a) whether it is possible to automatically identify the barrier causing a difficulty and (b) whether it is possible to determine the severity of the difficulty.  The project will start a new area of research exploring how difficulty-detection mechanisms should be designed, implemented, evaluated, and applied.\r\n\r\nBroader impacts:  If successful this research will lead to future work on a variety of difficulty amelioration mechanisms, including (a) allowing industrial workers and teachers to synchronously push help to developers facing difficulties; (b) informing developers facing difficulties about actions taken by others who overcame similar difficulties, so that they can take similar actions; (c) allowing assignment doers to anticipate the kind of difficulties they will encounter and thus be better prepared for the assignment;  and  (d) giving assignment definers an understanding of the inherent difficulty level of the assignment, which can lead to redefinition or better explanation of the assignment. These amelioration mechanisms can substantially reduce the high costs associated with software development and quality teaching, and transform collaborative software engineering and education. Such mechanisms can lead to significant productivity gains in industry, especially in distributed software development. An educational setting provides an even more compelling motivation because shyness of students and/or lack of instructor time prevents student difficulties from being addressed in a timely manner.  In computer science this is particularly a problem as a small mistake can prove to be very costly. The difficulty amelioration mechanisms will reduce this problem and thus attract a larger variety of students to computer science and empower those who are already committed to it.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "IIS",
 "org_div_long_name": "Division of Information & Intelligent Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Prasun",
   "pi_last_name": "Dewan",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Prasun Dewan",
   "pi_email_addr": "dewan@cs.unc.edu",
   "nsf_id": "000336210",
   "pi_start_date": "2012-08-25",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of North Carolina at Chapel Hill",
  "inst_street_address": "104 AIRPORT DR STE 2200",
  "inst_street_address_2": "",
  "inst_city_name": "CHAPEL HILL",
  "inst_state_code": "NC",
  "inst_state_name": "North Carolina",
  "inst_phone_num": "9199663411",
  "inst_zip_code": "275995023",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "NC04",
  "org_lgl_bus_name": "UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL",
  "org_prnt_uei_num": "D3LHU66KBLD5",
  "org_uei_num": "D3LHU66KBLD5"
 },
 "perf_inst": {
  "perf_inst_name": "University of North Carolina at Chapel Hill",
  "perf_str_addr": "201 S. Columbia st. CB 3175",
  "perf_city_name": "Chapel hill",
  "perf_st_code": "NC",
  "perf_st_name": "North Carolina",
  "perf_zip_code": "275993175",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "NC04",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "736700",
   "pgm_ele_name": "HCC-Human-Centered Computing"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "795300",
   "pgm_ele_name": "SOCIAL-COMPUTATIONAL SYSTEMS"
  },
  {
   "pgm_ele_code": "802000",
   "pgm_ele_name": "Cyberlearn & Future Learn Tech"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7367",
   "pgm_ref_txt": "Cyber-Human Systems"
  },
  {
   "pgm_ref_code": "7916",
   "pgm_ref_txt": "EAGER"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "7953",
   "pgm_ref_txt": "SOCIAL-COMPUTATIONAL SYSTEMS"
  },
  {
   "pgm_ref_code": "8045",
   "pgm_ref_txt": "Cyberlearn & Future Learn Tech"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 100000.0
  },
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 12480.0
  },
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 12480.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>An important form of group activity involves helping others with their difficulties. Previous research shows that helping others increases productivity in work environments and learning in educational environments, and that people are hesitant about asking for help. This project initiated a new line of research for automatically inferring the nature of difficulties of programmers, so that observers of this information can offer help. In industry, this work can reduce the cost of developing all forms of programs and improve their quality. In educational environments, the applications are as dramatic. Absence of help is a particular issue for underrepresented groups who often do not have a study group to help them. Several students are turned off by programming because a small mistake can prove to be very costly. Difficulty inferences can help retain and empower varied groups of students in programming-based courses and curricula.</p>\n<p>The goal of this project was to automatically determine the degree and type of difficulty faced by the programmer.</p>\n<p>To determine the difficulty degree, we performed lab study to distinguish between surmountable and insurmountable difficulties. Our observations showed that when subjects face insurmountable difficulties, they pause interaction, and when they face surmountable difficulties, they tend to repeat certain action sequences. Pausing of interaction also occurs when people take a break, so it was difficult to separate insurmountable difficulties from idle phases. Therefore, we assumed a two-phase scheme for detecting and classifying difficulties. In the first phase, some other algorithm or human input is used to determine the points at which difficulties arise. In the second phase, a level-detection algorithm is used to classify difficulties into surmountable and insurmountable. Our level-detection algorithm detected the sequences of actions that occur during surmountable difficulties to distinguish the surmountable difficulties from the insurmountable ones. Our evaluation shows that the mechanism gives significantly better results than the baselines. Part of this work was published in a refereed paper and Ph.D thesis.</p>\n<p>To determine the difficulty type or barrier, we did two field studies, one with industry workers and one with students. Our observations showed that when programmers had incorrect output, the execution rate and frequency of certain commands changed. Because of the problem of distinguishing between idle and pause phases, we again assumed a two-phase scheme for detecting and classifying difficulties in which in the second phase a barrier detection algorithm is used to classify difficulties found in the first phase. We developed a barrier detection algorithm that mined the rate and frequency of commands to separate design barriers from incorrect-output barriers and performed much better than the baselines. Part of this work was published in a refereed paper and a Ph.D. thesis.</p>\n<p>Our algorithms for difficulty classification depend on those for difficulty detection. Our previous difficulty detection scheme used only interaction logs. While such logs cannot distinguish between idle and difficulty phases, video streams can.&nbsp; We captured such streams and found that postures correlated with difficulties. We developed algorithms that detected postures from video streams, and then mined the postures to detect difficulties. In addition, we developed a multimodal algorithm for mining both video streams and interaction logs. Our results show that log-mining was more effective than posture-mining, though both had high false negative rates, and multimodal detection gave both low false positive and negative rates. Part of this work was published in a Ph.D thesis.</p>\n<p>To gain insight into industry applications of a difficulty-based collaboration environment, we conducted interviews with several mentor-int...",
  "por_txt_cntn": "\nAn important form of group activity involves helping others with their difficulties. Previous research shows that helping others increases productivity in work environments and learning in educational environments, and that people are hesitant about asking for help. This project initiated a new line of research for automatically inferring the nature of difficulties of programmers, so that observers of this information can offer help. In industry, this work can reduce the cost of developing all forms of programs and improve their quality. In educational environments, the applications are as dramatic. Absence of help is a particular issue for underrepresented groups who often do not have a study group to help them. Several students are turned off by programming because a small mistake can prove to be very costly. Difficulty inferences can help retain and empower varied groups of students in programming-based courses and curricula.\n\nThe goal of this project was to automatically determine the degree and type of difficulty faced by the programmer.\n\nTo determine the difficulty degree, we performed lab study to distinguish between surmountable and insurmountable difficulties. Our observations showed that when subjects face insurmountable difficulties, they pause interaction, and when they face surmountable difficulties, they tend to repeat certain action sequences. Pausing of interaction also occurs when people take a break, so it was difficult to separate insurmountable difficulties from idle phases. Therefore, we assumed a two-phase scheme for detecting and classifying difficulties. In the first phase, some other algorithm or human input is used to determine the points at which difficulties arise. In the second phase, a level-detection algorithm is used to classify difficulties into surmountable and insurmountable. Our level-detection algorithm detected the sequences of actions that occur during surmountable difficulties to distinguish the surmountable difficulties from the insurmountable ones. Our evaluation shows that the mechanism gives significantly better results than the baselines. Part of this work was published in a refereed paper and Ph.D thesis.\n\nTo determine the difficulty type or barrier, we did two field studies, one with industry workers and one with students. Our observations showed that when programmers had incorrect output, the execution rate and frequency of certain commands changed. Because of the problem of distinguishing between idle and pause phases, we again assumed a two-phase scheme for detecting and classifying difficulties in which in the second phase a barrier detection algorithm is used to classify difficulties found in the first phase. We developed a barrier detection algorithm that mined the rate and frequency of commands to separate design barriers from incorrect-output barriers and performed much better than the baselines. Part of this work was published in a refereed paper and a Ph.D. thesis.\n\nOur algorithms for difficulty classification depend on those for difficulty detection. Our previous difficulty detection scheme used only interaction logs. While such logs cannot distinguish between idle and difficulty phases, video streams can.  We captured such streams and found that postures correlated with difficulties. We developed algorithms that detected postures from video streams, and then mined the postures to detect difficulties. In addition, we developed a multimodal algorithm for mining both video streams and interaction logs. Our results show that log-mining was more effective than posture-mining, though both had high false negative rates, and multimodal detection gave both low false positive and negative rates. Part of this work was published in a Ph.D thesis.\n\nTo gain insight into industry applications of a difficulty-based collaboration environment, we conducted interviews with several mentor-intern pairs in a large industrial organization. We showed them the design of a user interface for s..."
 }
}