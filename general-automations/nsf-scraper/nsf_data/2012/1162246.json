{
 "awd_id": "1162246",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CSR: Medium: Collaborative Research: Portable Performance for Parallel Managed Languages Across the Many-Core Spectrum",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2012-06-01",
 "awd_exp_date": "2016-12-31",
 "tot_intn_awd_amt": 493938.0,
 "awd_amount": 509938.0,
 "awd_min_amd_letter_date": "2012-06-15",
 "awd_max_amd_letter_date": "2013-08-29",
 "awd_abstract_narration": "Computers with many tens to hundreds of ?cores? are on their way, but programming languages and tools\r\nthat exploit them well have lagged. At the same time, there are emerging programming languages intended\r\nfor writing programs to run on these computers. These languages, such as X10 and Fortress, add support for\r\nnew concepts that make it easier to write many-core programs, but there does not yet exist good compiler and\r\nrun-time support for these languages. Systems that run Java, namely Java virtual machines such as those that\r\nrun on virtually every laptop, desktop, and server today, supply much of what the new languages need, but\r\nfall short in some important ways. In particular they do not provide for saying in which part of memory to\r\nplace particular objects, on which core to run which computations, easy ways to get all cores busy working\r\non different parts of a big piece of data, or for synchronizing and getting right all the data manipulations\r\nhappening at the same time. This project is extending an existing research Java virtual machine (Jikes\r\nRVM) with support for many ways of doing the things that the new languages need in order to run well\r\non many-core computers. The primary goal is to devise extensions to standard Java virtual machines for\r\nthis new world, and to make it possible for many others to experiment with different ways of implementing\r\nthese extensions, thus leveraging the creativity of the whole community of language and virtual machine\r\nresearchers. Secondary goals include offering reasonably good initial implementations of virtual machine\r\nextensions as a starting point for future research and development, and proposing specific extensions to the\r\nJava virtual machine specification standard.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "J Eliot",
   "pi_last_name": "Moss",
   "pi_mid_init": "B",
   "pi_sufx_name": "",
   "pi_full_name": "J Eliot B Moss",
   "pi_email_addr": "moss@cs.umass.edu",
   "nsf_id": "000261930",
   "pi_start_date": "2012-06-15",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Timothy",
   "pi_last_name": "Richards",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Timothy Richards",
   "pi_email_addr": "richards@cs.umass.edu",
   "nsf_id": "000600567",
   "pi_start_date": "2012-06-15",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Massachusetts Amherst",
  "inst_street_address": "101 COMMONWEALTH AVE",
  "inst_street_address_2": "",
  "inst_city_name": "AMHERST",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "4135450698",
  "inst_zip_code": "010039252",
  "inst_country_name": "United States",
  "cong_dist_code": "02",
  "st_cong_dist_code": "MA02",
  "org_lgl_bus_name": "UNIVERSITY OF MASSACHUSETTS",
  "org_prnt_uei_num": "VGJHK59NMPK9",
  "org_uei_num": "VGJHK59NMPK9"
 },
 "perf_inst": {
  "perf_inst_name": "University of Massachusetts Amherst",
  "perf_str_addr": "140 Governors Drive",
  "perf_city_name": "Amherst",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "010039264",
  "perf_ctry_code": "US",
  "perf_cong_dist": "02",
  "perf_st_cong_dist": "MA02",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "171400",
   "pgm_ele_name": "Special Projects - CNS"
  },
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7354",
   "pgm_ref_txt": "COMPUTER SYSTEMS"
  },
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "9178",
   "pgm_ref_txt": "UNDERGRADUATE EDUCATION"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 168274.0
  },
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 341664.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>For some time, individual computer cores have not become faster, because they would overheat.&nbsp; To provide increasing computational power, computers now provide more \"cores\" (individual processors) on the same \"chip\" or board.&nbsp; Thus, to make an application run faster, it needs to be coded to use multiple cores.&nbsp; But this requires complex coordination between the cores, notoriously difficult to program.</p>\n<p>A feature called <em>transactions</em> helps simplify this programming, by allowing the programmer to indicate a whole series of steps that need to be done <em>as a unit</em> to avoid corrupting the computation.&nbsp; A classic example of this in real life is transferring funds between two accounts - one account must show the removal of funds and the other an addition of the same amount.&nbsp; It must not be possible to have only one part of the transaction occur, or else money has been (from the standpoint of the record keeping) created or it has disappeared, rather than simply moving.</p>\n<p>A variety of transaction schemes have been devised, and one achievement of this project was to implement a number of them for the Java programming language, in a way that can work for any Java implementation.&nbsp; Some schemes perform better than others in diffierent circumstances, so it turned out to be useful to support <em>multiple</em> schemes at once.</p>\n<p>Furthermore, transaction support in software involves noticeable bookkeeping overhead.&nbsp; Therefore, processor manufacturers have started to make available certain limited hardware support for transactions.&nbsp; This project developed ways to seamlessly run various transactions in hardware (when they meet the hardware's limitations) or in software (when they don't).&nbsp; Furthermore, it developed ways to use software to glue together multiple hardware transactions into a larger overall transaction, in certain circumstances (ones that can be expected to occur in many software libraries).</p>\n<p>In these ways the project contributed to making it easier to develop correct software that performs well for applications exploiting multiple cores on multicore computers.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 05/04/2017<br>\n\t\t\t\t\tModified by: J. Eliot&nbsp;B&nbsp;Moss</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nFor some time, individual computer cores have not become faster, because they would overheat.  To provide increasing computational power, computers now provide more \"cores\" (individual processors) on the same \"chip\" or board.  Thus, to make an application run faster, it needs to be coded to use multiple cores.  But this requires complex coordination between the cores, notoriously difficult to program.\n\nA feature called transactions helps simplify this programming, by allowing the programmer to indicate a whole series of steps that need to be done as a unit to avoid corrupting the computation.  A classic example of this in real life is transferring funds between two accounts - one account must show the removal of funds and the other an addition of the same amount.  It must not be possible to have only one part of the transaction occur, or else money has been (from the standpoint of the record keeping) created or it has disappeared, rather than simply moving.\n\nA variety of transaction schemes have been devised, and one achievement of this project was to implement a number of them for the Java programming language, in a way that can work for any Java implementation.  Some schemes perform better than others in diffierent circumstances, so it turned out to be useful to support multiple schemes at once.\n\nFurthermore, transaction support in software involves noticeable bookkeeping overhead.  Therefore, processor manufacturers have started to make available certain limited hardware support for transactions.  This project developed ways to seamlessly run various transactions in hardware (when they meet the hardware's limitations) or in software (when they don't).  Furthermore, it developed ways to use software to glue together multiple hardware transactions into a larger overall transaction, in certain circumstances (ones that can be expected to occur in many software libraries).\n\nIn these ways the project contributed to making it easier to develop correct software that performs well for applications exploiting multiple cores on multicore computers.\n\n\t\t\t\t\tLast Modified: 05/04/2017\n\n\t\t\t\t\tSubmitted by: J. Eliot B Moss"
 }
}