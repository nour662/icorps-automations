{
 "awd_id": "1219263",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "III: Small: Low latency browser-based web computation",
 "cfda_num": "47.070",
 "org_code": "05020000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Maria Zemankova",
 "awd_eff_date": "2012-10-01",
 "awd_exp_date": "2016-09-30",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 516000.0,
 "awd_min_amd_letter_date": "2012-09-09",
 "awd_max_amd_letter_date": "2013-06-13",
 "awd_abstract_narration": "The goal of this project is to provide an efficient platform for browser-based, data-driven web application computation. The platform enables cost-effective development of fast-responding applications that adjust well to accesses from mobile clients (e.g. smart phones, tablets).  The project achieves its goal using the following approaches: (1) designing novel high level, location-transparent, declarative, data-driven languages that require much lower coding effort than direct HTML5 coding in order to specify the business process and data access of the applications; (2) developing an optimizer for low latency query execution plans that utilize browser-based storage and asynchronous computation;  (3) developing an action scheduler that optimizes the location and execution order of the actions described in the declarative language; (4) developing a user/action concurrency control theory and a dependency analysis algorithm so that the user can view and act while prior actions are still computed; (5) prototyping an application-enabling platform that encompasses the developed languages, algorithms and optimizations; and (6) evaluating the effectiveness of the platform in two aspects: how much it reduces latency and how much it reduces the coding effort.\r\n\r\nThe project's research will have great impacts on mobile-accessible, data-driven web applications, which, by being written in the proposed automatically optimized, declarative languages, will enjoy both low latency and low development cost. The project supports graduate and undergraduate students. Lectures on the research results will be incorporated into PI's undergraduate-level course on web application development. Publications, software, an online service and experimental data from this research will be disseminated via the project web site (http://www.db.ucsd.edu/browserbasedforward).",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "IIS",
 "org_div_long_name": "Division of Information & Intelligent Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Yannis",
   "pi_last_name": "Papakonstantinou",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Yannis Papakonstantinou",
   "pi_email_addr": "yannis@cs.ucsd.edu",
   "nsf_id": "000229823",
   "pi_start_date": "2012-09-09",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-San Diego",
  "inst_street_address": "9500 GILMAN DR",
  "inst_street_address_2": "",
  "inst_city_name": "LA JOLLA",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "8585344896",
  "inst_zip_code": "920930021",
  "inst_country_name": "United States",
  "cong_dist_code": "50",
  "st_cong_dist_code": "CA50",
  "org_lgl_bus_name": "UNIVERSITY OF CALIFORNIA, SAN DIEGO",
  "org_prnt_uei_num": "",
  "org_uei_num": "UYTTZT6G9DT1"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-San Diego",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "920930404",
  "perf_ctry_code": "US",
  "perf_cong_dist": "50",
  "perf_st_cong_dist": "CA50",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "736400",
   "pgm_ele_name": "Info Integration & Informatics"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7364",
   "pgm_ref_txt": "INFO INTEGRATION & INFORMATICS"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 500000.0
  },
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>It is well known that implementing a data-driven application requires time and money. The result is that organizations, corporations and the government often lack the data analytics and management applications that they need since the budget limitations and the speed of business requirements do not allow for the needed applications to be built on time.</p>\n<p>A major source of the cost of building of data-driven applications is the fact that the application has to collect data from multiple sources, combine them and provide them with the appropriate format to the visualization components. It is both a blessing and a curse of the Big Data era that this source of cost is increasing. The Big Data era is characterized by a big diversity of databases. Besides the customary SQL databases, nowadays data are also found on NoSQL, NewSQL and SQL-on-Hadoop databases. Furthermore, interesting data are also found on the client device (typically smartphone) and its browser. Finally, the plethora of visualization components creates the need for easily adjusting the results to the formats that the visualizations need.</p>\n<p>Given the importance of semistructured data (such as JSON) both as input in NoSQL databases and as JSON (in particular) as the logical representation of the visualization input in MVVM architectures, the project created the SQL++ query language which accesses seamlessly both SQL and semistructured data. While the SQL++ idea (as an SQL extension for semistructured data) pre-existed, the project was focused on providing the full semistructured data functionality required - namely, account for the potential lack of schema, enable arbitrary inputs, outputs and transformations as powerful as the ones that XQuery achieved. Unlike XQuery this project was committed to produce an SQL compatible language, since this is what the majority of developers understands.<strong><br /></strong></p>\n<p>Per the original project objective, the project created a SQL++ distributed query processing engine, including the ability to refer to data on either the browser or&nbsp;server. Furthermore, the project addressed the case of live data, by developing Incremental View Maintenance that ensures that the views offered to the users are up-to-date, i.e., they reflect the state of the underlying databases.</p>\n<p>The project expanded SQL++ into a Configurable SQL++ that formally captures the query language differences across the multiple semistructured query languages of the multiple NoSQL, newSQL and SQL-on-Hadoop databases of today. Thus the Configurable SQL++ became a useful tool for formally surveying the semantic differences between the multiple languages for NoSQL, NewSQL and SQL-on-Hadoop. We disseminated the Configurable SQL++ to the industry, in the order of creating a dialog and a common understanding that will eventually will lead to the appropriate (for NoSQL, NewSQL and SQL-on-Hadoop) clean and formal extensions for extensions of the SQL standard.<strong>&nbsp;</strong>The response of the database industry to SQL++ and Configurable SQL++ has been excellent. A number of NoSQL databases adopt and we anticipate that SQL++ will further influence the database industry.</p>\n<p>Finally, Configurable SQL++ plays an internal role to the distributed query processor that accesses multiple sources of semistructured data. Recall, these sources are very diverse on the query languages that they use. Thus the distributed query processor needs to be able to interact with these diverse languages and rewrite the application requests into the languages they understand. Configurable SQL++ brings in a formal definition of the diversity aspects of the various languages. Then it becomes much easier for the distributed query processor to translate across these languages.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 08/11/2017<br>\n\t\t\t\t\tModified by: Yannis&nbsp;Papakonstantinou</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nIt is well known that implementing a data-driven application requires time and money. The result is that organizations, corporations and the government often lack the data analytics and management applications that they need since the budget limitations and the speed of business requirements do not allow for the needed applications to be built on time.\n\nA major source of the cost of building of data-driven applications is the fact that the application has to collect data from multiple sources, combine them and provide them with the appropriate format to the visualization components. It is both a blessing and a curse of the Big Data era that this source of cost is increasing. The Big Data era is characterized by a big diversity of databases. Besides the customary SQL databases, nowadays data are also found on NoSQL, NewSQL and SQL-on-Hadoop databases. Furthermore, interesting data are also found on the client device (typically smartphone) and its browser. Finally, the plethora of visualization components creates the need for easily adjusting the results to the formats that the visualizations need.\n\nGiven the importance of semistructured data (such as JSON) both as input in NoSQL databases and as JSON (in particular) as the logical representation of the visualization input in MVVM architectures, the project created the SQL++ query language which accesses seamlessly both SQL and semistructured data. While the SQL++ idea (as an SQL extension for semistructured data) pre-existed, the project was focused on providing the full semistructured data functionality required - namely, account for the potential lack of schema, enable arbitrary inputs, outputs and transformations as powerful as the ones that XQuery achieved. Unlike XQuery this project was committed to produce an SQL compatible language, since this is what the majority of developers understands.\n\n\nPer the original project objective, the project created a SQL++ distributed query processing engine, including the ability to refer to data on either the browser or server. Furthermore, the project addressed the case of live data, by developing Incremental View Maintenance that ensures that the views offered to the users are up-to-date, i.e., they reflect the state of the underlying databases.\n\nThe project expanded SQL++ into a Configurable SQL++ that formally captures the query language differences across the multiple semistructured query languages of the multiple NoSQL, newSQL and SQL-on-Hadoop databases of today. Thus the Configurable SQL++ became a useful tool for formally surveying the semantic differences between the multiple languages for NoSQL, NewSQL and SQL-on-Hadoop. We disseminated the Configurable SQL++ to the industry, in the order of creating a dialog and a common understanding that will eventually will lead to the appropriate (for NoSQL, NewSQL and SQL-on-Hadoop) clean and formal extensions for extensions of the SQL standard. The response of the database industry to SQL++ and Configurable SQL++ has been excellent. A number of NoSQL databases adopt and we anticipate that SQL++ will further influence the database industry.\n\nFinally, Configurable SQL++ plays an internal role to the distributed query processor that accesses multiple sources of semistructured data. Recall, these sources are very diverse on the query languages that they use. Thus the distributed query processor needs to be able to interact with these diverse languages and rewrite the application requests into the languages they understand. Configurable SQL++ brings in a formal definition of the diversity aspects of the various languages. Then it becomes much easier for the distributed query processor to translate across these languages.\n\n\t\t\t\t\tLast Modified: 08/11/2017\n\n\t\t\t\t\tSubmitted by: Yannis Papakonstantinou"
 }
}