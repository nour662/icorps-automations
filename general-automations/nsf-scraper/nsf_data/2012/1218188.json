{
 "awd_id": "1218188",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "AF: SMALL: Collaborative Research: Data Structures for Parallel Algorithms",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Tracy Kimbrel",
 "awd_eff_date": "2012-08-01",
 "awd_exp_date": "2015-07-31",
 "tot_intn_awd_amt": 138994.0,
 "awd_amount": 138994.0,
 "awd_min_amd_letter_date": "2012-07-20",
 "awd_max_amd_letter_date": "2012-07-20",
 "awd_abstract_narration": "This project develops a theory for characterizing the performance of parallel data structures and parallel algorithms that use parallel structures.  Standard metrics for parallel algorithms, such as \"work\" (total amount of computation) and \"span\" (critical-path length), do not naturally generalize in the presence of contention on shared data.  Moreover, standard approaches for analyzing sequential data structures, such as amortization, do not seem to generalize when data structures are parallel, in part because the performance depends on the properties of the underlying parallel task schedulers.\r\n\r\nThe specific research goals are as follows:  \r\n(1) Investigate a methodology for designing and analyzing parallel algorithms that use data structures, especially amortized ones. \r\n(2) Design parallel schedulers that ameliorate the contention on parallel data structures. \r\n(3) Design parallel data structures that perform provably well with these schedulers.\r\n\r\nToday parallel computing is ubiquitous.  Modern computation platforms---smartphones to network routers, personal computers to large clusters and clouds---each contain multiple processors.  Writing parallel code that provably scales well is challenging, and techniques for analyzing sequential algorithms and data structures generally do not apply to parallel code.  This project will develop a theoretical foundation for characterizing the scalability of parallel programs that contend for access to shared data.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Jeremy",
   "pi_last_name": "Fineman",
   "pi_mid_init": "T",
   "pi_sufx_name": "",
   "pi_full_name": "Jeremy T Fineman",
   "pi_email_addr": "jfineman@cs.georgetown.edu",
   "nsf_id": "000610554",
   "pi_start_date": "2012-07-20",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Georgetown University",
  "inst_street_address": "MAIN CAMPUS",
  "inst_street_address_2": "",
  "inst_city_name": "WASHINGTON",
  "inst_state_code": "DC",
  "inst_state_name": "District of Columbia",
  "inst_phone_num": "2026250100",
  "inst_zip_code": "20057",
  "inst_country_name": "United States",
  "cong_dist_code": "00",
  "st_cong_dist_code": "DC00",
  "org_lgl_bus_name": "GEORGETOWN UNIVERSITY",
  "org_prnt_uei_num": "TF2CMKY1HMX9",
  "org_uei_num": "TF2CMKY1HMX9"
 },
 "perf_inst": {
  "perf_inst_name": "Georgetown University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "DC",
  "perf_st_name": "District of Columbia",
  "perf_zip_code": "200571789",
  "perf_ctry_code": "US",
  "perf_cong_dist": "00",
  "perf_st_cong_dist": "DC00",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779600",
   "pgm_ele_name": "Algorithmic Foundations"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7926",
   "pgm_ref_txt": "ALGORITHMS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 138994.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The goal of this project is to develop a theory for characterizing the performance of parallel data structures and parallel algorithms that use data structures. &nbsp;Standard metrics for parallel algorithms, such as \"work\" (total amount of computation) and \"span\" (length of the critical path), do not naturally generalize in the presence of contention on shared data. Moreover, the standard approaches for analyzing sequential data structures, such as amortization, do not seem to generalize when data structures are used in parallel, in part because the performance depends on properties of the scheduler.</p>\n<p>The main outcomes of this project are:</p>\n<p>1) A new work-stealing scheduler that interacts well with certain types of data structures. The scheduler is accompanied by a strong performance theorem for the overall running time of parallel programs that uses certain types of data structures. The performance theorem relies on easy-to-use metrics (in addition to work and span), and the guarantees readily extend even to amortized data structures.</p>\n<p>2) A runtime-system implementation, called BATCHER, that implements the above scheduler and makes it easier to incorporate data structures into a parallel program. One of the key advantages of BATCHER is that it uses batched data structures instead of concurrent data structures. Implementing efficient batched operations (using standard parallel constructs) can be much easier than coping with arbitrary concurrency. BATCHER automatically groups operations into batches, essentially transforming a program that makes concurrent accesses into one that makes batched accesses.&nbsp;</p>\n<p>3) A new on-the-fly \"determinacy race\" detector. Two data accesses are logically parallel if they allowed to be reordered with respect to each other by the scheduler. If two accesses to the same location are logically parallel, and at least one of those accesses is a write, then a determinacy race occurs. Determinacy races lead to nondeterministic program behavior, and as such they are difficult to reason about. This nondeterminacy is often unintential and indicates a bug in the program. A race detector is a tool for discovering determinacy races in a program execution. Some determinacy race detectors rely on shared data structures. This project addresses one of those shared data structures and includes an implementation of the resulting determinacy-race detector.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/28/2015<br>\n\t\t\t\t\tModified by: Jeremy&nbsp;T&nbsp;Fineman</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe goal of this project is to develop a theory for characterizing the performance of parallel data structures and parallel algorithms that use data structures.  Standard metrics for parallel algorithms, such as \"work\" (total amount of computation) and \"span\" (length of the critical path), do not naturally generalize in the presence of contention on shared data. Moreover, the standard approaches for analyzing sequential data structures, such as amortization, do not seem to generalize when data structures are used in parallel, in part because the performance depends on properties of the scheduler.\n\nThe main outcomes of this project are:\n\n1) A new work-stealing scheduler that interacts well with certain types of data structures. The scheduler is accompanied by a strong performance theorem for the overall running time of parallel programs that uses certain types of data structures. The performance theorem relies on easy-to-use metrics (in addition to work and span), and the guarantees readily extend even to amortized data structures.\n\n2) A runtime-system implementation, called BATCHER, that implements the above scheduler and makes it easier to incorporate data structures into a parallel program. One of the key advantages of BATCHER is that it uses batched data structures instead of concurrent data structures. Implementing efficient batched operations (using standard parallel constructs) can be much easier than coping with arbitrary concurrency. BATCHER automatically groups operations into batches, essentially transforming a program that makes concurrent accesses into one that makes batched accesses. \n\n3) A new on-the-fly \"determinacy race\" detector. Two data accesses are logically parallel if they allowed to be reordered with respect to each other by the scheduler. If two accesses to the same location are logically parallel, and at least one of those accesses is a write, then a determinacy race occurs. Determinacy races lead to nondeterministic program behavior, and as such they are difficult to reason about. This nondeterminacy is often unintential and indicates a bug in the program. A race detector is a tool for discovering determinacy races in a program execution. Some determinacy race detectors rely on shared data structures. This project addresses one of those shared data structures and includes an implementation of the resulting determinacy-race detector.\n\n\t\t\t\t\tLast Modified: 10/28/2015\n\n\t\t\t\t\tSubmitted by: Jeremy T Fineman"
 }
}