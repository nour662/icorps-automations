{
 "awd_id": "1144506",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "Ab Initio Models of Solar Activity",
 "cfda_num": "47.070",
 "org_code": "05090000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Irene Qualters",
 "awd_eff_date": "2012-08-01",
 "awd_exp_date": "2016-07-31",
 "tot_intn_awd_amt": 37434.0,
 "awd_amount": 37434.0,
 "awd_min_amd_letter_date": "2012-08-03",
 "awd_max_amd_letter_date": "2012-08-03",
 "awd_abstract_narration": "The scientific objectives of this research are to understand how internal solar magnetoconvection powers the Suns activity, and how that activity heats the chromosphere and corona and accelerates charged particles to relativistic energies.\r\nThe approach uses three-dimensional, compressible, finite difference, magnetohydrodynamic (MHD) codes to solve the equations for mass, momentum and internal energy in conservative form plus the induction equation for the magnetic field. A particle in-cell plasma code is used to calculate charged particle acceleration and radiation in regions of reconnecting magnetic fields.  The project has requested and been granted a substantial allocation of computer resources on the leadership class Blue Waters system at NCSA.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "OAC",
 "org_div_long_name": "Office of Advanced Cyberinfrastructure (OAC)",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Robert",
   "pi_last_name": "Stein",
   "pi_mid_init": "F",
   "pi_sufx_name": "",
   "pi_full_name": "Robert F Stein",
   "pi_email_addr": "stein@pa.msu.edu",
   "nsf_id": "000166522",
   "pi_start_date": "2012-08-03",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "William",
   "pi_last_name": "Abbett",
   "pi_mid_init": "P",
   "pi_sufx_name": "",
   "pi_full_name": "William P Abbett",
   "pi_email_addr": "abbett@ssl.berkeley.edu",
   "nsf_id": "000331859",
   "pi_start_date": "2012-08-03",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Bart",
   "pi_last_name": "De Pontieu",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Bart De Pontieu",
   "pi_email_addr": "bdp@lmsal.com",
   "nsf_id": "000571294",
   "pi_start_date": "2012-08-03",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Mats",
   "pi_last_name": "Carlsson",
   "pi_mid_init": "",
   "pi_sufx_name": "Dr.",
   "pi_full_name": "Mats Carlsson",
   "pi_email_addr": "mats.carlsson@astro.uio.no",
   "nsf_id": "000059910",
   "pi_start_date": "2012-08-03",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Aake",
   "pi_last_name": "Nordlund",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Aake Nordlund",
   "pi_email_addr": "aake@nbi.dk",
   "nsf_id": "000595720",
   "pi_start_date": "2012-08-03",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Michigan State University",
  "inst_street_address": "426 AUDITORIUM RD RM 2",
  "inst_street_address_2": "",
  "inst_city_name": "EAST LANSING",
  "inst_state_code": "MI",
  "inst_state_name": "Michigan",
  "inst_phone_num": "5173555040",
  "inst_zip_code": "488242600",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MI07",
  "org_lgl_bus_name": "MICHIGAN STATE UNIVERSITY",
  "org_prnt_uei_num": "VJKZC4D1JN36",
  "org_uei_num": "R28EKN92ZTZ9"
 },
 "perf_inst": {
  "perf_inst_name": "Michigan State University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "MI",
  "perf_st_name": "Michigan",
  "perf_zip_code": "488242320",
  "perf_ctry_code": "US",
  "perf_cong_dist": null,
  "perf_st_cong_dist": "MI",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "778100",
   "pgm_ele_name": "Leadership-Class Computing"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7781",
   "pgm_ref_txt": "PETASCALE - TRACK 1"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 37434.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Attemping to run an existing radiation-magneto-hydrodynamic code on the massively parallel Blue Waters supercomputer showed us that a fundamentally new approach was needed to efficiently use it and the even larger exascale computers that will be available in the near future. &nbsp;To this end we started developing the DISPATCH computing framework.</p>\n<p>DISPATCH is a revolutionary new task-based, adaptive mesh refinement framework which overcomes the limitations of traditional methods using four novel concepts: (A) small (in index space), adaptively refined Cartesian patches. (B) Asynchronous evolution of these patches in time and space, (C) OpenMP task-based scheduling on each node, and (D) overlapping non-blocking point-to-point MPI communications between nodes with computations. Dispatch uses the existing stagger and other MHD solvers.</p>\n<p>DISPATCH geometrically sub-divides the simulation domain for the purpose of MPI decomposition. Each MPI rank then sub-divides itself into small curvilinear meshes (patches). By choosing small patch sizes (16^3 - 32^3 cells) one can achieve good cache performance on modern CPUs, take full advantage of the vectorization properties of these CPUs, and communicate full patches to other MPI processes in negligible time. Each patch is updated independently, once guard zone values have been loaded from neighboring patches. The maximum allowed time step is determined locally, with a Courant number (ratio of time step to time for sound waves to cross on grid cell) of about 0.2 suitable for the stagger MHD solver. Because of the locally determined time step, a number of time slices (typically 5) are saved in a rotating buffer, for use when interpolating guard zone values to the times required by neighboring patches. By letting the patches evolve asynchronously one avoids the problem with exceptional local time steps affecting the entire simulation. Coupled with task based scheduling, where each patch is a task, a local slowdown in one task only has a minor effect on simulation performance as a whole, and, contrary to conventional codes, the impact decreases further as the number of cores increases, thus leading to exceptional parallel scalability, expected to continue to millions of cores in the near-future exa-scale era. By having many geometrically small patches at the surface and fewer, geometrically larger patches in the interior, computing power is concentrated where it is most needed. A small fraction of the patches -- particularly above sunspots -- require very small time steps, but their number is not large enough to increase the overall update cost much. This is in contrast to traditional codes, where the smallest time step would be imposed on the entire simulation volume. In principle, patches cannot update until neighboring patches are updated, which could lead to a situation where only one patch (the oldest one) was eligible for update at any one time. &nbsp;To alleviate this constraint, a grace parameter is introduced, as the fraction of a time step one is allowed to extrapolate neighboring patch values in time, in order to fill the guard zones. A setting of 0.05 is typically sufficient to allow a large number of patches to update without delay.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/16/2016<br>\n\t\t\t\t\tModified by: Robert&nbsp;F&nbsp;Stein</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nAttemping to run an existing radiation-magneto-hydrodynamic code on the massively parallel Blue Waters supercomputer showed us that a fundamentally new approach was needed to efficiently use it and the even larger exascale computers that will be available in the near future.  To this end we started developing the DISPATCH computing framework.\n\nDISPATCH is a revolutionary new task-based, adaptive mesh refinement framework which overcomes the limitations of traditional methods using four novel concepts: (A) small (in index space), adaptively refined Cartesian patches. (B) Asynchronous evolution of these patches in time and space, (C) OpenMP task-based scheduling on each node, and (D) overlapping non-blocking point-to-point MPI communications between nodes with computations. Dispatch uses the existing stagger and other MHD solvers.\n\nDISPATCH geometrically sub-divides the simulation domain for the purpose of MPI decomposition. Each MPI rank then sub-divides itself into small curvilinear meshes (patches). By choosing small patch sizes (16^3 - 32^3 cells) one can achieve good cache performance on modern CPUs, take full advantage of the vectorization properties of these CPUs, and communicate full patches to other MPI processes in negligible time. Each patch is updated independently, once guard zone values have been loaded from neighboring patches. The maximum allowed time step is determined locally, with a Courant number (ratio of time step to time for sound waves to cross on grid cell) of about 0.2 suitable for the stagger MHD solver. Because of the locally determined time step, a number of time slices (typically 5) are saved in a rotating buffer, for use when interpolating guard zone values to the times required by neighboring patches. By letting the patches evolve asynchronously one avoids the problem with exceptional local time steps affecting the entire simulation. Coupled with task based scheduling, where each patch is a task, a local slowdown in one task only has a minor effect on simulation performance as a whole, and, contrary to conventional codes, the impact decreases further as the number of cores increases, thus leading to exceptional parallel scalability, expected to continue to millions of cores in the near-future exa-scale era. By having many geometrically small patches at the surface and fewer, geometrically larger patches in the interior, computing power is concentrated where it is most needed. A small fraction of the patches -- particularly above sunspots -- require very small time steps, but their number is not large enough to increase the overall update cost much. This is in contrast to traditional codes, where the smallest time step would be imposed on the entire simulation volume. In principle, patches cannot update until neighboring patches are updated, which could lead to a situation where only one patch (the oldest one) was eligible for update at any one time.  To alleviate this constraint, a grace parameter is introduced, as the fraction of a time step one is allowed to extrapolate neighboring patch values in time, in order to fill the guard zones. A setting of 0.05 is typically sufficient to allow a large number of patches to update without delay.\n\n \n\n \n\n \n\n \n\n\t\t\t\t\tLast Modified: 11/16/2016\n\n\t\t\t\t\tSubmitted by: Robert F Stein"
 }
}