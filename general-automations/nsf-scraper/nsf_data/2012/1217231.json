{
 "awd_id": "1217231",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CSR: Small: Collaborative Research: Real-Time Unobtrusive Tracing in Multicore Embedded Systems",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2012-09-01",
 "awd_exp_date": "2016-08-31",
 "tot_intn_awd_amt": 172960.0,
 "awd_amount": 188960.0,
 "awd_min_amd_letter_date": "2012-08-16",
 "awd_max_amd_letter_date": "2014-02-05",
 "awd_abstract_narration": "Embedded computer systems have become essential to many aspects of our lives. Cheaper, smaller, faster, more sophisticated, and more energy-efficient embedded devices spur ever new applications. However, the growing complexity and shift to multicores make programming and debugging these systems difficult. Traditional debugging is time consuming and may interfere with program execution, causing some bugs to become irreproducible and making it unusable in real-time environments. Moreover, tracing a processor?s internal state during execution is only feasible for short program segments and requires large on-chip buffers or wide trace ports, either of which increases system cost and limits scalability.  This project is developing the next generation of trace compression methods and infrastructure to make continuous, real-time, unobtrusive, and cost-effective program, data, and bus tracing possible in embedded systems. The approach relies on on-chip hardware to record the processor state and corresponding software modules in the debugger. The novel insight is that a sequence of trace records can be translated, without loss of information, into a much shorter sequence of miss events using small hardware structures. The few remaining miss events are then further compressed using highly-effective yet simple-to-implement encoding schemes, yielding heretofore unseen compression ratios.\r\n\r\nThe new tracing and debugging infrastructure can help programmers find difficult and intermittent software bugs faster, thus improving productivity. For example, reducing debugging time by just one percent amounts to hundreds of millions of dollars annually in saved salaries, with a concomitant reduction in software cost and time to market. Moreover, higher quality software may eliminate errors in medical, automotive, or mission-critical devices and thus save lives.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Martin",
   "pi_last_name": "Burtscher",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Martin Burtscher",
   "pi_email_addr": "burtscher@txstate.edu",
   "nsf_id": "000572212",
   "pi_start_date": "2012-08-16",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Texas State University - San Marcos",
  "inst_street_address": "601 UNIVERSITY DR",
  "inst_street_address_2": "",
  "inst_city_name": "SAN MARCOS",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "5122452314",
  "inst_zip_code": "786664684",
  "inst_country_name": "United States",
  "cong_dist_code": "15",
  "st_cong_dist_code": "TX15",
  "org_lgl_bus_name": "TEXAS STATE UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HS5HWWK1AAU5"
 },
 "perf_inst": {
  "perf_inst_name": "Texas State University - San Marcos",
  "perf_str_addr": "601 University Drive",
  "perf_city_name": "San Marcos",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "786664684",
  "perf_ctry_code": "US",
  "perf_cong_dist": "15",
  "perf_st_cong_dist": "TX15",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9178",
   "pgm_ref_txt": "UNDERGRADUATE EDUCATION"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 172960.0
  },
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Our society increasingly relies upon embedded computer systems that have become essential to many aspects of our lives, including transportation, civil infrastructure, and medicine. Faster, cheaper, smaller, more sophisticated, and more energy-efficient embedded computer systems spur new applications that require very complex programming. The growing software and hardware complexity and tightening time-to-market deadlines make programming and debugging the most critical aspect of embedded system development. According to one study, software developers spend between 50% and 75% of their time debugging programs, yet the nation still loses approximately $20 to $60 billion a year due to software bugs and glitches. The ongoing shift toward larger numbers of processing cores makes software development and debugging even more challenging. Traditional debugging is time consuming and may interfere with program execution, causing some bugs to become irreproducible and making it unusable in real-time settings such as ignition timing of piston engines. Such systems need to be tested in production environments and must be bug-free. Of course, achieving bug-free software is a challenging proposition in general and especially given the exponential growth in hardware and software complexity. Current solutions only allow the tracing of a processor&rsquo;s internal state for short program segments and require large on-chip buffers or wide trace ports, both of which increase system cost and limit scalability, making these solutions untenable.</p>\n<p>The main goal of this project is developing the next generation of trace compression methods and infrastructure to make continuous, real-time, unobtrusive, and cost-effective program and data tracing possible in embedded systems. Our approach relies on on-chip hardware to record the processor state and corresponding software modules in the debugger. The novel insight is that a sequence of trace records can be translated, without loss of information, into a much shorter sequence using simple yet highly-effective hardware structures, yielding heretofore unreached compression ratios. The new tracing and debugging hardware resources, coupled with sophisticated software debuggers, enable programmers to find difficult and intermittent software bugs faster, resulting in improved reliability and quality of software as well as increased overall productivity. For example, reducing debugging time by just 1% amounts to hundreds of millions of dollars annually in saved salaries, with a concomitant reduction in software cost and time-to-market. Moreover, higher quality software may eliminate errors in medical, automotive, and aviation devices and thus save lives. Our research demonstrates how to design such trace-compression methods that provide real-time, unobtrusive, and cost-effective program and data tracing for future generations of embedded processors.</p>\n<p>The primary accomplishment is a first-of-its-kind framework for the automatic and systematic creation of effective compression algorithms. Based on a detailed literature search, we extracted and generalized many &ldquo;components&rdquo; from previously published compression algorithms. In our framework, each component uses the same interface to transform an input sequence of values into an output sequence. The common interface makes it possible to replace any component with any other. More importantly, the components can be chained such that the output sequence of one component becomes the input sequence of the next component, thus creating arbitrarily complex chains, that is, compression algorithms. Finally, for each component, we implemented a corresponding inverse component. This approach has two main benefits. First, any combination of components results in a valid algorithm (that may or may not compress the traces well). Second, chaining the inverse components in the opposite direction automatically yields the needed decompression algorithm. Based on this infrastructure, we developed search strategies for automatically determining good compression algorithms. For small numbers of components, we use an exhaustive search. For larger numbers of components, we use a genetic algorithm. Our framework can be employed to independently find good compression algorithms for different trace types. By removing unsuitable components (e.g., with overly large table sizes or complexity), the framework automatically synthesizes well-performing algorithms that can be implemented in hardware without exceeding the available chip resources. This work has initiated a new era in data compression. Heretofore, only relatively few compression algorithms have been published and evaluated. They are all carefully designed by hand to exploit known patterns in data. Our approach makes it possible, for the first time, to literally evaluate millions of compression algorithms and to employ sophisticated search algorithms to automatically find and generate compression algorithms that are tailored to a specific domain (e.g., a specific kind of program trace), adhere to given constraints (e.g., a maximum table size), and deliver superior compression ratios.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/28/2016<br>\n\t\t\t\t\tModified by: Martin&nbsp;Burtscher</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nOur society increasingly relies upon embedded computer systems that have become essential to many aspects of our lives, including transportation, civil infrastructure, and medicine. Faster, cheaper, smaller, more sophisticated, and more energy-efficient embedded computer systems spur new applications that require very complex programming. The growing software and hardware complexity and tightening time-to-market deadlines make programming and debugging the most critical aspect of embedded system development. According to one study, software developers spend between 50% and 75% of their time debugging programs, yet the nation still loses approximately $20 to $60 billion a year due to software bugs and glitches. The ongoing shift toward larger numbers of processing cores makes software development and debugging even more challenging. Traditional debugging is time consuming and may interfere with program execution, causing some bugs to become irreproducible and making it unusable in real-time settings such as ignition timing of piston engines. Such systems need to be tested in production environments and must be bug-free. Of course, achieving bug-free software is a challenging proposition in general and especially given the exponential growth in hardware and software complexity. Current solutions only allow the tracing of a processor?s internal state for short program segments and require large on-chip buffers or wide trace ports, both of which increase system cost and limit scalability, making these solutions untenable.\n\nThe main goal of this project is developing the next generation of trace compression methods and infrastructure to make continuous, real-time, unobtrusive, and cost-effective program and data tracing possible in embedded systems. Our approach relies on on-chip hardware to record the processor state and corresponding software modules in the debugger. The novel insight is that a sequence of trace records can be translated, without loss of information, into a much shorter sequence using simple yet highly-effective hardware structures, yielding heretofore unreached compression ratios. The new tracing and debugging hardware resources, coupled with sophisticated software debuggers, enable programmers to find difficult and intermittent software bugs faster, resulting in improved reliability and quality of software as well as increased overall productivity. For example, reducing debugging time by just 1% amounts to hundreds of millions of dollars annually in saved salaries, with a concomitant reduction in software cost and time-to-market. Moreover, higher quality software may eliminate errors in medical, automotive, and aviation devices and thus save lives. Our research demonstrates how to design such trace-compression methods that provide real-time, unobtrusive, and cost-effective program and data tracing for future generations of embedded processors.\n\nThe primary accomplishment is a first-of-its-kind framework for the automatic and systematic creation of effective compression algorithms. Based on a detailed literature search, we extracted and generalized many \"components\" from previously published compression algorithms. In our framework, each component uses the same interface to transform an input sequence of values into an output sequence. The common interface makes it possible to replace any component with any other. More importantly, the components can be chained such that the output sequence of one component becomes the input sequence of the next component, thus creating arbitrarily complex chains, that is, compression algorithms. Finally, for each component, we implemented a corresponding inverse component. This approach has two main benefits. First, any combination of components results in a valid algorithm (that may or may not compress the traces well). Second, chaining the inverse components in the opposite direction automatically yields the needed decompression algorithm. Based on this infrastructure, we developed search strategies for automatically determining good compression algorithms. For small numbers of components, we use an exhaustive search. For larger numbers of components, we use a genetic algorithm. Our framework can be employed to independently find good compression algorithms for different trace types. By removing unsuitable components (e.g., with overly large table sizes or complexity), the framework automatically synthesizes well-performing algorithms that can be implemented in hardware without exceeding the available chip resources. This work has initiated a new era in data compression. Heretofore, only relatively few compression algorithms have been published and evaluated. They are all carefully designed by hand to exploit known patterns in data. Our approach makes it possible, for the first time, to literally evaluate millions of compression algorithms and to employ sophisticated search algorithms to automatically find and generate compression algorithms that are tailored to a specific domain (e.g., a specific kind of program trace), adhere to given constraints (e.g., a maximum table size), and deliver superior compression ratios.\n\n\t\t\t\t\tLast Modified: 11/28/2016\n\n\t\t\t\t\tSubmitted by: Martin Burtscher"
 }
}