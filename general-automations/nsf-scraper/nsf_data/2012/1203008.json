{
 "awd_id": "1203008",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Effectful Software Contracts",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2011-08-01",
 "awd_exp_date": "2014-07-31",
 "tot_intn_awd_amt": 440760.0,
 "awd_amount": 440760.0,
 "awd_min_amd_letter_date": "2011-10-24",
 "awd_max_amd_letter_date": "2011-10-24",
 "awd_abstract_narration": "The long-term goals of this project are to bring the technology of software contracts to widely-used programming languages and, through\r\nthe use of manifest contracts, to provide software developers with a migration path from simply-typed code to fully functional correctness.  Since computational effects are notoriously hard to reason about and\r\npervade even the simplest realistic programs, the proposed research should have significant impact on programmers' ability to develop\r\nsoftware that is more reliable and more secure. \r\n\r\nContracts in software establish clear interfaces between program components.  Like contracts in the legal realm, they delineate each\r\nparty's expectations and obligations.  Such contracts are becoming increasingly important for the regulation of modern software systems,\r\nproviding an expressive framework for verification and error tracking.  To be effective in a software environment, contracts must have formal semantics and must be supported by a monitoring system that precisely\r\ntracks the flow of values as they cross interfaces.  To date, however, the formal study of contracts has mostly been limited to small\r\nidealized languages without computational effects, such as reading data from or writing data to a display or file, managing resources\r\nsuch as memory, and performing probabilistic or speculative computation.\r\n\r\nThis research aims to extend the semantic framework of software contracts to languages with various computational effects: the\r\nextension is qualitative in nature and will enable the use of contracts in new application domains.  Specifically, the PIs propose\r\nto add support for computational effects to the two flavors of contracts studied to date: latent contracts, which are runtime checks\r\nnot reflected in the type system, and manifest contracts, where a system of precise types records the most recent runtime check applied\r\nto each value.  The extension of latent contracts will be done in the context of a monadic meta language.  The extension of manifest\r\ncontracts will make use of a variant of Hoare Type Theory to precisely record computational effects.  The PIs will also implement prototype systems and use them to present novel applications of software\r\ncontracts.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Amal",
   "pi_last_name": "Ahmed",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Amal Ahmed",
   "pi_email_addr": "amal@ccs.neu.edu",
   "nsf_id": "000573498",
   "pi_start_date": "2011-10-24",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Northeastern University",
  "inst_street_address": "360 HUNTINGTON AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BOSTON",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6173735600",
  "inst_zip_code": "021155005",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "NORTHEASTERN UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HLTMVS2JZBS6"
 },
 "perf_inst": {
  "perf_inst_name": "Northeastern University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021155005",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 440760.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Just like its business counterpart, a software contract is a binding agreement between a producer and a consumer. Simple examples of contracts, technically known as \"first-order contracts,\" have long been integral to various programming languages and libraries and routinely used by software developers for debugging and ultimately for quality assurance. Such contracts are characterized by the fact that it is computationally trivial to check and enforce the contract. For example, checking that a submitted billing address matches the official address on record is an operation that can efficiently implemented and enforced. As data has become &ldquo;bigger&rdquo; and as software has become more complex, writing enforceable contracts has become a scientific subject of its own. For example, checking that a submitted tax return is valid requires a tedious calculation involving a significant amount of communication and exchange of additional information. In fact, the computation involved in enforcing the contract becomes so significant that it itself might be subject to further constraints to ensure that its effect on the underlying computation is well-understood and regulated.</p>\n<p><br />These concerns technically translate to a formal analysis of contracts in the presence of higher-order functions, effectful operations, large data structures, lazy languages, and even software components written in different languages. As has become apparent in the past few years,in these situations, the behavior of contract checking becomes more complex. With higher-order functions, contracts must be delayed; with large data structures, contracts must trade-off the amount of checking with the time needed for traversing the data structures; with lazy languages, contracts must be adapted so as not to force excess evaluation of delayed computations; and with multi-language systems there are few formal results.</p>\n<p>A first major result of our project is the development of a foundational approach for expressing complex contracts as communication patterns in an ambient system of communicating processes. The approach generalizes and subsumes previous semantic frameworks and is readily amenable to a distributed implementation.This system allows each contract to specify its own evaluation strategy, enforcement policy, and interactions with the underlying computation. The second major technical result is to leverage (statically checked) contracts and multi-language systems to tackle a challenging open problem in compiler verification described next.</p>\n<p>A compiler translates code written in a high-level programming language to the low-level machine code that actually runs on a processor. Compilers play a critical role in the production of our software infrastructure and as such they should be correct. Though there has been remarkable progress on formally verified compilers in recent years, almost all of these compilers suffer from a serious limitation: they are proved correct under the assumption that they will only be used to compile *whole* programs. This is an unrealistic assumption since most software systems today are comprised of *components* written in different languages compiled by different compilers to a common low-level target language.</p>\n<p>A key challenge when compiling components is that it is not clear how to even state the compiler correctness theorem. Stating such theorems is easy when compiling whole programs: if the high-level program H compiles to a low-level program L, then running both H and L should result in the same trace of observable events. The same sort of theorem does not make sense when we compile a component: we cannot \"run\" a component because it is not a complete program.</p>\n<p>Our project has shown how to leverage contracts and multi-language systems to verify correct compilation of *components* while formally allowing these components to be linked wit...",
  "por_txt_cntn": "\nJust like its business counterpart, a software contract is a binding agreement between a producer and a consumer. Simple examples of contracts, technically known as \"first-order contracts,\" have long been integral to various programming languages and libraries and routinely used by software developers for debugging and ultimately for quality assurance. Such contracts are characterized by the fact that it is computationally trivial to check and enforce the contract. For example, checking that a submitted billing address matches the official address on record is an operation that can efficiently implemented and enforced. As data has become \"bigger\" and as software has become more complex, writing enforceable contracts has become a scientific subject of its own. For example, checking that a submitted tax return is valid requires a tedious calculation involving a significant amount of communication and exchange of additional information. In fact, the computation involved in enforcing the contract becomes so significant that it itself might be subject to further constraints to ensure that its effect on the underlying computation is well-understood and regulated.\n\n\nThese concerns technically translate to a formal analysis of contracts in the presence of higher-order functions, effectful operations, large data structures, lazy languages, and even software components written in different languages. As has become apparent in the past few years,in these situations, the behavior of contract checking becomes more complex. With higher-order functions, contracts must be delayed; with large data structures, contracts must trade-off the amount of checking with the time needed for traversing the data structures; with lazy languages, contracts must be adapted so as not to force excess evaluation of delayed computations; and with multi-language systems there are few formal results.\n\nA first major result of our project is the development of a foundational approach for expressing complex contracts as communication patterns in an ambient system of communicating processes. The approach generalizes and subsumes previous semantic frameworks and is readily amenable to a distributed implementation.This system allows each contract to specify its own evaluation strategy, enforcement policy, and interactions with the underlying computation. The second major technical result is to leverage (statically checked) contracts and multi-language systems to tackle a challenging open problem in compiler verification described next.\n\nA compiler translates code written in a high-level programming language to the low-level machine code that actually runs on a processor. Compilers play a critical role in the production of our software infrastructure and as such they should be correct. Though there has been remarkable progress on formally verified compilers in recent years, almost all of these compilers suffer from a serious limitation: they are proved correct under the assumption that they will only be used to compile *whole* programs. This is an unrealistic assumption since most software systems today are comprised of *components* written in different languages compiled by different compilers to a common low-level target language.\n\nA key challenge when compiling components is that it is not clear how to even state the compiler correctness theorem. Stating such theorems is easy when compiling whole programs: if the high-level program H compiles to a low-level program L, then running both H and L should result in the same trace of observable events. The same sort of theorem does not make sense when we compile a component: we cannot \"run\" a component because it is not a complete program.\n\nOur project has shown how to leverage contracts and multi-language systems to verify correct compilation of *components* while formally allowing these components to be linked with low-level code of arbitrary provenance. The essential intuition is that compiler correctness should guarant..."
 }
}