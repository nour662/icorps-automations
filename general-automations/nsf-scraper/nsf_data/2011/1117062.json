{
 "awd_id": "1117062",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Parallel Unified Linear algebra with Systolic ARrays (PULSAR)",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927498",
 "po_email": "achtchel@nsf.gov",
 "po_sign_block_name": "Almadena Chtchelkanova",
 "awd_eff_date": "2011-08-01",
 "awd_exp_date": "2014-07-31",
 "tot_intn_awd_amt": 499996.0,
 "awd_amount": 499996.0,
 "awd_min_amd_letter_date": "2011-07-20",
 "awd_max_amd_letter_date": "2011-07-20",
 "awd_abstract_narration": "More than seven years after traditional processor designs hit the edge of their power envelope, the path of extreme scale Computational Science to a 100 petaflop (Pflop/s) system, which researchers had hoped to be using by the middle of the coming decade, has never looked steeper. On current high performance computing (HPC) systems, the 'application-architecture performance gap,' i.e. the gap between theoretical peak performance and the performance realized by full applications is already substantial. But with clock frequencies now capped below 4 GHz and trending downward, latencies in key areas (e.g. memory access, bus, system interconnect) expected to remain relatively stagnant, and software parallelism required to increase by at least three orders of magnitude to make effective use of the tens of thousands of processors and millions of cores that 100 Pflop/s systems are projected to contain, it is now reasonable to worry that a widening application-architecture performance gap will make such systems unproductive to use and therefore irrational to build. \r\n\r\nThe proposed research aims to provide the kind of coordinated math and computer science research effort needed to solve the interrelated cluster of software problems that threaten to cripple application performance on future large-scale systems.  Under the PULSAR project, the PIs use a variety of both classic and novel dense linear algebra algorithms to explore the potential of well known, but now little used systolic array design principles to exploit all the power that future multi-core and heterogeneous systems, built to extreme scales.   If a software platform that virtualizes classic systolic array architecture, allowing for suitable flexibility in the granularity of its application can be created, then libraries and applications that use this data-driven execution model to achieve outstanding performance and scalability on future massively parallel and data-starved HPC systems can be produced.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Jack",
   "pi_last_name": "Dongarra",
   "pi_mid_init": "J",
   "pi_sufx_name": "",
   "pi_full_name": "Jack J Dongarra",
   "pi_email_addr": "dongarra@icl.utk.edu",
   "nsf_id": "000299281",
   "pi_start_date": "2011-07-20",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Piotr",
   "pi_last_name": "Luszczek",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Piotr Luszczek",
   "pi_email_addr": "luszczek@icl.utk.edu",
   "nsf_id": "000296500",
   "pi_start_date": "2011-07-20",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Jakub",
   "pi_last_name": "Kurzak",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Jakub Kurzak",
   "pi_email_addr": "kurzak@cs.utk.edu",
   "nsf_id": "000492052",
   "pi_start_date": "2011-07-20",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Tennessee Knoxville",
  "inst_street_address": "201 ANDY HOLT TOWER",
  "inst_street_address_2": "",
  "inst_city_name": "KNOXVILLE",
  "inst_state_code": "TN",
  "inst_state_name": "Tennessee",
  "inst_phone_num": "8659743466",
  "inst_zip_code": "379960001",
  "inst_country_name": "United States",
  "cong_dist_code": "02",
  "st_cong_dist_code": "TN02",
  "org_lgl_bus_name": "UNIVERSITY OF TENNESSEE",
  "org_prnt_uei_num": "LXG4F9K8YZK5",
  "org_uei_num": "FN2YCS2YAUW3"
 },
 "perf_inst": {
  "perf_inst_name": "University of Tennessee Knoxville",
  "perf_str_addr": "201 ANDY HOLT TOWER",
  "perf_city_name": "KNOXVILLE",
  "perf_st_code": "TN",
  "perf_st_name": "Tennessee",
  "perf_zip_code": "379960001",
  "perf_ctry_code": "US",
  "perf_cong_dist": "02",
  "perf_st_cong_dist": "TN02",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7942",
   "pgm_ref_txt": "HIGH-PERFORMANCE COMPUTING"
  },
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 499996.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The hypothesis of the PULSAR project was that systolic arrays could serve as inspiration for a programming model capable of scaling to the full size of the largest supercomputers. This challenge means targeting machines that include hundreds of thousands of CPU cores and tens of thousands of GPU accelerators. Sheer size being a challenge on its own, these machines also have very complex architectures, with multiple levels of memories and network interconnections. The motivation for seeking a new programming model is that no single unified programming paradigm for such machines exists. Instead, at least three different ones are mixed together. A common case would be a mix of the MPI, OpenMP, and CUDA programming systems.</p>\n<p>What PULSAR offers as an alternative is a programming model where the user defines the computation in the form of a <em>Virtual Systolic Array</em> (VSA), which is a set of <em>Virtual Data Processors</em> (VDPs), connected with data channels. The VDP is assigned a function, which defines its operation. Within that function, the VDP has access to a set of global parameters, its private persistent local storage, and its channels. The runtime invokes that function when there are packets in all of the VDP&rsquo;s input channels. This is called firing. When the VDP fires, it can fetch packets from its input channels, call computational kernels, and push packets to its output channels. It is not required that these operations are invoked in any particular order. The VDP fires a prescribed number of times. When the VDP&rsquo;s counter goes down to zero, the VDP is destroyed. The VSA contains all VDPs and their channel connections, and stores the information about the mapping of VDPs to the CPUs and GPUs. The VSA needs to be created first and then launched. First, an empty VSA is created, then VDPs are inserted in the VSA, followed by execution of the VSA by the PULSAR runtime system, and finally by its destruction. Figure 1 illustrates the basic concept.</p>\n<p>This programming model is accessible to the user <em>through a very small and simple Application Programming Interface</em> (API). All the complexity of executing the workload on a large-scale system is hidden in the runtime implementation. While the user invokes simple push and pull channel operations, the runtime takes appropriate actions, depending on the boundaries crossed by the channel, i.e., uses shared memory for VDPs residing in the same node, uses message-passing for VDPs residing in different nodes, uses <em>Direct Memory Access</em> (DMA) transfers between CPU VDPs and GPU VDPs.</p>\n<p>The runtime operates a dedicated management thread, called the proxy, which handles communication within each node. The proxy thread manages multiple message queues to handle both intra-node (DMA) communications and inter-node (MPI) communications. The left image in Figure 2 shows the communication system for nodes with CPUs only, while the right image shows the communication system for nodes with CPUs and GPUs. In the most complex case of VDP residing in GPUs located in two different nodes, the runtime will invoke a sequence of DMA and MPI transfers to move the data from one VDP to the other, all while the user only invokes simple push and pull actions.</p>\n<p>We used the PUSAR system to implement systolic algorithms for the LU factorization and the QR factorization. Our published results include a 2D systolic algorithm for the QR factorization of square matrices, and a 3D systolic algorithm for the QR factorization of tall-and-skinny matrices. We ran the first one on up to 23,000 CPU cores and the second one on up to 15,000 cores and showed that they consistently outperform existing numerical software.</p>\n<p>We envision the longevity of the PULSAR system far beyond its funding period. While we proved the benefits of PULSAR for implementing dense linear algebra algorithms, we clearly see its appl...",
  "por_txt_cntn": "\nThe hypothesis of the PULSAR project was that systolic arrays could serve as inspiration for a programming model capable of scaling to the full size of the largest supercomputers. This challenge means targeting machines that include hundreds of thousands of CPU cores and tens of thousands of GPU accelerators. Sheer size being a challenge on its own, these machines also have very complex architectures, with multiple levels of memories and network interconnections. The motivation for seeking a new programming model is that no single unified programming paradigm for such machines exists. Instead, at least three different ones are mixed together. A common case would be a mix of the MPI, OpenMP, and CUDA programming systems.\n\nWhat PULSAR offers as an alternative is a programming model where the user defines the computation in the form of a Virtual Systolic Array (VSA), which is a set of Virtual Data Processors (VDPs), connected with data channels. The VDP is assigned a function, which defines its operation. Within that function, the VDP has access to a set of global parameters, its private persistent local storage, and its channels. The runtime invokes that function when there are packets in all of the VDP\u00c6s input channels. This is called firing. When the VDP fires, it can fetch packets from its input channels, call computational kernels, and push packets to its output channels. It is not required that these operations are invoked in any particular order. The VDP fires a prescribed number of times. When the VDP\u00c6s counter goes down to zero, the VDP is destroyed. The VSA contains all VDPs and their channel connections, and stores the information about the mapping of VDPs to the CPUs and GPUs. The VSA needs to be created first and then launched. First, an empty VSA is created, then VDPs are inserted in the VSA, followed by execution of the VSA by the PULSAR runtime system, and finally by its destruction. Figure 1 illustrates the basic concept.\n\nThis programming model is accessible to the user through a very small and simple Application Programming Interface (API). All the complexity of executing the workload on a large-scale system is hidden in the runtime implementation. While the user invokes simple push and pull channel operations, the runtime takes appropriate actions, depending on the boundaries crossed by the channel, i.e., uses shared memory for VDPs residing in the same node, uses message-passing for VDPs residing in different nodes, uses Direct Memory Access (DMA) transfers between CPU VDPs and GPU VDPs.\n\nThe runtime operates a dedicated management thread, called the proxy, which handles communication within each node. The proxy thread manages multiple message queues to handle both intra-node (DMA) communications and inter-node (MPI) communications. The left image in Figure 2 shows the communication system for nodes with CPUs only, while the right image shows the communication system for nodes with CPUs and GPUs. In the most complex case of VDP residing in GPUs located in two different nodes, the runtime will invoke a sequence of DMA and MPI transfers to move the data from one VDP to the other, all while the user only invokes simple push and pull actions.\n\nWe used the PUSAR system to implement systolic algorithms for the LU factorization and the QR factorization. Our published results include a 2D systolic algorithm for the QR factorization of square matrices, and a 3D systolic algorithm for the QR factorization of tall-and-skinny matrices. We ran the first one on up to 23,000 CPU cores and the second one on up to 15,000 cores and showed that they consistently outperform existing numerical software.\n\nWe envision the longevity of the PULSAR system far beyond its funding period. While we proved the benefits of PULSAR for implementing dense linear algebra algorithms, we clearly see its applicability to a much larger range of problems, including stencil computations and neural networks. We expect PULSAR to have significant impac..."
 }
}