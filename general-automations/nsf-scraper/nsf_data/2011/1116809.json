{
 "awd_id": "1116809",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CSR:Small:Kalipers-Deep Energy Inspection of Operating System Components",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2011-08-15",
 "awd_exp_date": "2014-07-31",
 "tot_intn_awd_amt": 449998.0,
 "awd_amount": 449998.0,
 "awd_min_amd_letter_date": "2011-08-08",
 "awd_max_amd_letter_date": "2011-08-08",
 "awd_abstract_narration": "The electrical power used by all classes of computers is becoming of increasing importance.  A major component of the cost of running large server operations is power, and, on the other end, the utility of laptops, palmtops, pads, and other portable devices is highly constrained by their batteries? capacity to power operations.  \r\nOne important element of the power used by computers is that burned by the operating system, the software that controls the computer?s operation.  Little is known about the impact different operating system options have on a machine?s power budget, due to difficulties with existing technology in precisely measuring power use and correctly ascribing power expended to its true source.  Thus, determining if scheduling algorithm alternatives, different forms of memory management, or different security options offered by the operating system have good, bad, or neutral power impacts has been difficult.  The Kalipers project will address this issue by using new technology to obtain detailed and reliable information about how important operating system components affect machine power use.\r\nKalipers will achieve this goal through a program of experimentation using a unique hardware/software platform called LEAP.  The LEAP platform, which we have already built and tested, allows fine-grained assignments of power use to particular piece of code.  It also measures the differing power consumption by important system components, such as the CPU, the memory, and the hard drive.  We will use the LEAP?s capabilities to determine how operating system actions and decisions affect the power use of platforms that have strong needs to minimize their power budget.\r\nOur experiments will be concentrated in three areas:  file systems, memory management, and security services.  These are areas we have experience in and where we have reason to believe power savings can be found.  We will investigate alternative technologies (such as the power costs of different file systems, or software vs. hardware full disk encryption).  The LEAP technology will allow us to dive more deeply into the power costs of different system components, allowing us to shed light on issues like the degree to which higher power costs for ext3 are due to its implementation details and the degree to which they are inherent in the journaling nature of that file system.  We will also reimplement key components of the operating system to demonstrate how the knowledge we have gained can be used to improve a system?s power consumption.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Peter",
   "pi_last_name": "Reiher",
   "pi_mid_init": "L",
   "pi_sufx_name": "",
   "pi_full_name": "Peter L Reiher",
   "pi_email_addr": "reiher@cs.ucla.edu",
   "nsf_id": "000245809",
   "pi_start_date": "2011-08-08",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "William",
   "pi_last_name": "Kaiser",
   "pi_mid_init": "J",
   "pi_sufx_name": "",
   "pi_full_name": "William J Kaiser",
   "pi_email_addr": "kaiser@ee.ucla.edu",
   "nsf_id": "000325518",
   "pi_start_date": "2011-08-08",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-Los Angeles",
  "inst_street_address": "10889 WILSHIRE BLVD STE 700",
  "inst_street_address_2": "",
  "inst_city_name": "LOS ANGELES",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "3107940102",
  "inst_zip_code": "900244200",
  "inst_country_name": "United States",
  "cong_dist_code": "36",
  "st_cong_dist_code": "CA36",
  "org_lgl_bus_name": "UNIVERSITY OF CALIFORNIA, LOS ANGELES",
  "org_prnt_uei_num": "",
  "org_uei_num": "RN64EPNH8JC6"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-Los Angeles",
  "perf_str_addr": "10889 WILSHIRE BLVD STE 700",
  "perf_city_name": "LOS ANGELES",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "900244200",
  "perf_ctry_code": "US",
  "perf_cong_dist": "36",
  "perf_st_cong_dist": "CA36",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7354",
   "pgm_ref_txt": "COMPUTER SYSTEMS"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 449998.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>As we rely ever more heavily on computers to run our modern world, they require an ever-increasing amount of power.&nbsp; Minimizing the power a computer requires to perform its operations is thus extremely important.<br /><br />However, existing techniques for measuring computers&rsquo; power consumption are inadequate.&nbsp; A commonplace among engineers is that one cannot optimize what one cannot measure.&nbsp; The available techniques to measure a machine&rsquo;s power use tend to rely on attaching power meters to the machine&rsquo;s power cord, or using a rough heuristic that the amount of time a computer requires to do something is closely related to the amount of power it uses for that purpose.&nbsp; While these techniques are somewhat accurate at a rather gross level, they offer little help in determining whether making changes to some particular piece of software will result in more power use, less power use, or no difference.&nbsp; <br /><br />The Kalipers project addressed this issue in the particular context of system software, which includes the operating system that sits below all user applications and controls the computer&rsquo;s hardware.&nbsp; Kalipers used a combination of minor hardware alterations and software analysis to provide, for the first time, a detailed, accurate measurement of how much power was used to run a particular piece of system software.&nbsp; Knowing this, software developers could determine whether that piece of code performed a critical, power-expensive operation whose optimization would make a huge difference, or if that code represented a rarely-performed function that used little power.&nbsp; Further, experimental changes could be compared to the previous version&rsquo;s behavior, telling the developers if they had improved power use.<br /><br />We demonstrated the Kalipers approach by applying our experimental system to several operating system functions, measuring their power behavior and seeking opportunities to improve it.&nbsp; For example, we performed a detailed analysis of Linux&rsquo;s file I/O subsystem, which handles all file reads and writes, and thus is heavily used and of critical importance.&nbsp; Moreover, it typically uses a disk drive to store and retrieve this data; disk drives consume a great deal of power when actively used.&nbsp; This investigation was challenging because modern file I/O systems perform many complex operations to improve the speed of file I/O, including caching, batching multiple requests, and scheduling when to use the disk hardware for particular reads and writes.&nbsp; As a result, the code that handles one particular read or write tends not to be done all at once, but is interspersed with many other system operations.&nbsp; That makes determining the power cost of one particular I/O challenging.&nbsp; To do so, in addition to adding software probes into appropriate places in the operating system, we had to tag system resources related to particular I/O operations to allow us to determine which I/O was being serviced by the OS code.<br /><br />As another example, on modern computers, there are several pieces of hardware that can run instructions.&nbsp; These are called cores, and a computer might have four or more cores, which allows it to potentially run that many programs simultaneously.&nbsp; This requires the computer&rsquo;s operating system to decide which of several programs to run on which core at any given instant.&nbsp; There are detailed performance issues related to the costs of running programs on particular cores.&nbsp; For example, if two programs both need exclusive access to the same data, they cannot be run simultaneously, so putting them on two separate cores will likely not improve their performance.&nbsp; One of them will always be waiting for access to the shared data, while the other is using it.&nbsp; The power implications of how these scheduling decisions...",
  "por_txt_cntn": "\nAs we rely ever more heavily on computers to run our modern world, they require an ever-increasing amount of power.  Minimizing the power a computer requires to perform its operations is thus extremely important.\n\nHowever, existing techniques for measuring computers\u00c6 power consumption are inadequate.  A commonplace among engineers is that one cannot optimize what one cannot measure.  The available techniques to measure a machine\u00c6s power use tend to rely on attaching power meters to the machine\u00c6s power cord, or using a rough heuristic that the amount of time a computer requires to do something is closely related to the amount of power it uses for that purpose.  While these techniques are somewhat accurate at a rather gross level, they offer little help in determining whether making changes to some particular piece of software will result in more power use, less power use, or no difference.  \n\nThe Kalipers project addressed this issue in the particular context of system software, which includes the operating system that sits below all user applications and controls the computer\u00c6s hardware.  Kalipers used a combination of minor hardware alterations and software analysis to provide, for the first time, a detailed, accurate measurement of how much power was used to run a particular piece of system software.  Knowing this, software developers could determine whether that piece of code performed a critical, power-expensive operation whose optimization would make a huge difference, or if that code represented a rarely-performed function that used little power.  Further, experimental changes could be compared to the previous version\u00c6s behavior, telling the developers if they had improved power use.\n\nWe demonstrated the Kalipers approach by applying our experimental system to several operating system functions, measuring their power behavior and seeking opportunities to improve it.  For example, we performed a detailed analysis of Linux\u00c6s file I/O subsystem, which handles all file reads and writes, and thus is heavily used and of critical importance.  Moreover, it typically uses a disk drive to store and retrieve this data; disk drives consume a great deal of power when actively used.  This investigation was challenging because modern file I/O systems perform many complex operations to improve the speed of file I/O, including caching, batching multiple requests, and scheduling when to use the disk hardware for particular reads and writes.  As a result, the code that handles one particular read or write tends not to be done all at once, but is interspersed with many other system operations.  That makes determining the power cost of one particular I/O challenging.  To do so, in addition to adding software probes into appropriate places in the operating system, we had to tag system resources related to particular I/O operations to allow us to determine which I/O was being serviced by the OS code.\n\nAs another example, on modern computers, there are several pieces of hardware that can run instructions.  These are called cores, and a computer might have four or more cores, which allows it to potentially run that many programs simultaneously.  This requires the computer\u00c6s operating system to decide which of several programs to run on which core at any given instant.  There are detailed performance issues related to the costs of running programs on particular cores.  For example, if two programs both need exclusive access to the same data, they cannot be run simultaneously, so putting them on two separate cores will likely not improve their performance.  One of them will always be waiting for access to the shared data, while the other is using it.  The power implications of how these scheduling decisions are made were particularly murky.  We used our Kalipers approach to measure the power use resulting from different choices.  Based on that, we built a new scheduler algorithm that made better choices from a power use perspective.  It was able ..."
 }
}