{
 "awd_id": "1142905",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "EAGER: PXFS - A Persistent Storage Model for Extreme Scale",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927498",
 "po_email": "achtchel@nsf.gov",
 "po_sign_block_name": "Almadena Chtchelkanova",
 "awd_eff_date": "2011-08-01",
 "awd_exp_date": "2014-07-31",
 "tot_intn_awd_amt": 299796.0,
 "awd_amount": 299796.0,
 "awd_min_amd_letter_date": "2011-07-14",
 "awd_max_amd_letter_date": "2011-07-14",
 "awd_abstract_narration": "The challenges of Exascale computing suggest that a new model of computation is needed upon\r\nwhich a new framework for mass storage may be built. Such a model currently under development is the\r\nParalleX model. ParalleX addresses Exascale parallelism by removing most (if not all) global\r\nsynchronization and providing a natural means for programs to manage local dependencies that maintain\r\nconsistency. In a similar manner, we propose to develop a model of parallel storage that achieves the\r\ndesired semantics without global synchronization. At the same time, the model will adopt a new\r\nprogrammer interface that reflects this approach. This I/O model is named PXFS and is intended to be\r\nintegrated with the ParalleX model of computation, both by providing an I/O model for ParalleX and by\r\nbeing defined in terms of ParalleX.\r\nThe goals of the proposed research are to derive a new model of persistent mass storage that\r\nunifies it with active in-memory data and develop PXFS, a proof-of-concept file system to enable\r\neffective and scalable Exascale computing. The objectives of the proposed project are to describe the\r\nPXFS model in complete terms, develop an initial reference implementation integrated with the HPX\r\nimplementation of ParalleX, and evaluate the model via the reference implementation.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Walter",
   "pi_last_name": "Ligon",
   "pi_mid_init": "B",
   "pi_sufx_name": "",
   "pi_full_name": "Walter B Ligon",
   "pi_email_addr": "walt@clemson.edu",
   "nsf_id": "000359301",
   "pi_start_date": "2011-07-14",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Clemson University",
  "inst_street_address": "201 SIKES HALL",
  "inst_street_address_2": "",
  "inst_city_name": "CLEMSON",
  "inst_state_code": "SC",
  "inst_state_name": "South Carolina",
  "inst_phone_num": "8646562424",
  "inst_zip_code": "296340001",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "SC03",
  "org_lgl_bus_name": "CLEMSON UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "H2BMNX7DSKU8"
 },
 "perf_inst": {
  "perf_inst_name": "Clemson University",
  "perf_str_addr": "300 Brackett Hall, Box 345702",
  "perf_city_name": "Clemson",
  "perf_st_code": "SC",
  "perf_st_name": "South Carolina",
  "perf_zip_code": "296340001",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "SC03",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7916",
   "pgm_ref_txt": "EAGER"
  },
  {
   "pgm_ref_code": "7942",
   "pgm_ref_txt": "HIGH-PERFORMANCE COMPUTING"
  },
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 299796.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Science and engineering are increasingly reliant on the execution of realistic simulation models.&nbsp; Simulation is faster and cheaper than physical experimentation, and while it doesn&rsquo;t eliminate the need for experiments it can dramatically reduce the time and cost needed to get to a working solution.&nbsp;&nbsp; Simulations require significant amounts of computation and can both consume and generate very large amounts of data.&nbsp; Today simulations use a computational technique known as parallel processing to provided the needed computational performance.&nbsp; Parallel processing refers to using hundreds or even thousands or more computer processors to work together to solve a single large problem.&nbsp; Parallel processing can be quite difficult to use properly and many problems lose performance dramatically when the number of processing elements gets very large.&nbsp; In order to allow these problems to scale to next generation computer systems, the ParalleX computational model has been proposed.&nbsp; ParalleX describes a way of organizing computer code so that it can scale effectively to extremely large numbers of processors.&nbsp; Until now ParalleX only defined computations, but modern problems perform as much data I/O as computation.&nbsp; This project has focused on defining an I/O framework for ParalleX.<br /><br />Under this project we developed PXFS, an I/O subsystem for a programming environment based on ParalleX called HPX.&nbsp; HPX is a system based on c++ that manages the creation, execution, and interaction of threads on a large distributed computer system.&nbsp; PXFS is based on the Parallel Virtual File System (PVFS) which is an open source system for performing I/O on a large distributed computer system.&nbsp; The primary goal of the project was to develop requirements for PXFS by developing a prototype.&nbsp; The prototype used PVFS file server processes, and part of the PVFS API but built a new interface on top in order to understand how these two complex software systems might interact.<br /><br />One of the main issues discovered in this project was that HPX assumes complete control over threads execution on a given computer in the system.&nbsp; This became problematic, because PVFS regularly interacts with the computer&rsquo;s operating system in a way that would cause all of the HPX threads to stop while I/O was being done.&nbsp; To remedy this it was clear that the HPX/PVFS interface had to employ a asynchronous model.&nbsp; The first approach employed used an asynchronous layer on top of the PVFS file system interface.&nbsp; This layer was constructed to look much like the common POSIX API, but allowed each call to execute in the background and call a completion function when it had finished.&nbsp; This was implemented using a distinct thread which solved the conflict discussed, but was not particularly efficient.</p>\n<p>Experiments run on the interface showed very little overhead over standard interfaces, and even a performance benefit because I/O could be submitted concurrently.&nbsp; It was theorized that poor interaction with HPX was the culprit.&nbsp; Subsequent experimentation involved powering the asynchronous interface with an HPX thread which allowed HPX to manage the I/O.&nbsp; This produced good results.&nbsp; Additional experiments involved moving the I/O processing from an HPX compute node to a PVFS server node and using HPX active messaging to send data for I/O.&nbsp; This produced even better results because the I/O processing was removed from the compute nodes completely.<br /><br />Thus, the results of this project were to define an appropriate architecture for PXFS as the addition of HPX communication capability to storage nodes rather than the addition of storage processing on compute nodes.&nbsp; It also demonstrated that this can be done with a very low overhead and that the inherent support for highly a...",
  "por_txt_cntn": "\nScience and engineering are increasingly reliant on the execution of realistic simulation models.  Simulation is faster and cheaper than physical experimentation, and while it doesn\u00c6t eliminate the need for experiments it can dramatically reduce the time and cost needed to get to a working solution.   Simulations require significant amounts of computation and can both consume and generate very large amounts of data.  Today simulations use a computational technique known as parallel processing to provided the needed computational performance.  Parallel processing refers to using hundreds or even thousands or more computer processors to work together to solve a single large problem.  Parallel processing can be quite difficult to use properly and many problems lose performance dramatically when the number of processing elements gets very large.  In order to allow these problems to scale to next generation computer systems, the ParalleX computational model has been proposed.  ParalleX describes a way of organizing computer code so that it can scale effectively to extremely large numbers of processors.  Until now ParalleX only defined computations, but modern problems perform as much data I/O as computation.  This project has focused on defining an I/O framework for ParalleX.\n\nUnder this project we developed PXFS, an I/O subsystem for a programming environment based on ParalleX called HPX.  HPX is a system based on c++ that manages the creation, execution, and interaction of threads on a large distributed computer system.  PXFS is based on the Parallel Virtual File System (PVFS) which is an open source system for performing I/O on a large distributed computer system.  The primary goal of the project was to develop requirements for PXFS by developing a prototype.  The prototype used PVFS file server processes, and part of the PVFS API but built a new interface on top in order to understand how these two complex software systems might interact.\n\nOne of the main issues discovered in this project was that HPX assumes complete control over threads execution on a given computer in the system.  This became problematic, because PVFS regularly interacts with the computer\u00c6s operating system in a way that would cause all of the HPX threads to stop while I/O was being done.  To remedy this it was clear that the HPX/PVFS interface had to employ a asynchronous model.  The first approach employed used an asynchronous layer on top of the PVFS file system interface.  This layer was constructed to look much like the common POSIX API, but allowed each call to execute in the background and call a completion function when it had finished.  This was implemented using a distinct thread which solved the conflict discussed, but was not particularly efficient.\n\nExperiments run on the interface showed very little overhead over standard interfaces, and even a performance benefit because I/O could be submitted concurrently.  It was theorized that poor interaction with HPX was the culprit.  Subsequent experimentation involved powering the asynchronous interface with an HPX thread which allowed HPX to manage the I/O.  This produced good results.  Additional experiments involved moving the I/O processing from an HPX compute node to a PVFS server node and using HPX active messaging to send data for I/O.  This produced even better results because the I/O processing was removed from the compute nodes completely.\n\nThus, the results of this project were to define an appropriate architecture for PXFS as the addition of HPX communication capability to storage nodes rather than the addition of storage processing on compute nodes.  It also demonstrated that this can be done with a very low overhead and that the inherent support for highly asynchronous I/O can be very beneficial.  This has led to a new proposal based on these results where we intend to integrate I/O into the HPX model in such a way that it becomes transparent to the user where storage ends and memory begi..."
 }
}