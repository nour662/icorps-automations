{
 "awd_id": "1117805",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CSR: Small: LOOM: a Language and System for Bypassing and Diagnosing Concurrency Errors",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Anita La Salle",
 "awd_eff_date": "2011-09-01",
 "awd_exp_date": "2014-08-31",
 "tot_intn_awd_amt": 250000.0,
 "awd_amount": 266000.0,
 "awd_min_amd_letter_date": "2011-08-19",
 "awd_max_amd_letter_date": "2013-05-31",
 "awd_abstract_narration": "This project addresses programming challenges posed by the new trend in multicore computing.\r\n\r\nMultithreaded programs are difficult to write, test, and debug. They often contain numerous insidious concurrency errors, including data races, atomicity violations, and order violations, which we broadly define to be races. A good deal of prior research has focused on race detection.  However, little progress has been made to help developers fix races because existing systems for fixing races work only with a small, fixed set of race patterns and, for the most part, do not work with simple order violations, a common type of concurrency errors.\r\n\r\nThe research objective of this project, LOOM: a Language and System for Bypassing and Diagnosing Concurrency Errors, is to create effective systems and technologies to help developers fix races.  A preliminary study revealed a key challenge yet to be addressed on fixing races that is, how to help developers immediately protect deployed programs from known races.  Even with the correct diagnosis of a race, fixing this race in a deployed program is complicated and time consuming. This delay leaves large vulnerability windows potentially compromising reliability and security.\r\n\r\nTo address these challenges, the LOOM project is creating an intuitive, expressive synchronization language and a system called LOOM for bypassing races in live programs.  The language enables developers to write declarative, succinct execution filters to describe their synchronization intents on code.  To fix races, LOOM installs these filters in live programs for immediate protection against races, until a software update is available and the program can be restarted.\r\n\r\nThe greatest impact of this project will be a new, effective language and system and novel technologies to improve the reliability of multithreaded program, benefiting business, government, and individuals.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Junfeng",
   "pi_last_name": "Yang",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Junfeng Yang",
   "pi_email_addr": "junfeng@cs.columbia.edu",
   "nsf_id": "000509381",
   "pi_start_date": "2011-08-19",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Columbia University",
  "inst_street_address": "615 W 131ST ST",
  "inst_street_address_2": "MC 8741",
  "inst_city_name": "NEW YORK",
  "inst_state_code": "NY",
  "inst_state_name": "New York",
  "inst_phone_num": "2128546851",
  "inst_zip_code": "100277922",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "NY13",
  "org_lgl_bus_name": "THE TRUSTEES OF COLUMBIA UNIVERSITY IN THE CITY OF NEW YORK",
  "org_prnt_uei_num": "",
  "org_uei_num": "F4N1QNPB95M4"
 },
 "perf_inst": {
  "perf_inst_name": "Columbia University",
  "perf_str_addr": "615 W 131ST ST",
  "perf_city_name": "NEW YORK",
  "perf_st_code": "NY",
  "perf_st_name": "New York",
  "perf_zip_code": "100277922",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "NY13",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "171400",
   "pgm_ele_name": "Special Projects - CNS"
  },
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7354",
   "pgm_ref_txt": "COMPUTER SYSTEMS"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9178",
   "pgm_ref_txt": "UNDERGRADUATE EDUCATION"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 250000.0
  },
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Two trends make multithreaded programs increasingly critical. The first is a hardware trend:&nbsp;the rise of multicore. For years, single-threaded code enjoyed automatic speedup as computer&nbsp;architects steadilymade single-coremultiprocessors faster. Recently, however, this &ldquo;free lunch is over&rdquo;:&nbsp;power and wire-delay constraints have forced microprocessors into multicore designs, and adding&nbsp;more cores does not automatically speed up single-threaded code.</p>\n<p>The second is a software trend: the coming storm of cloud computing. More and more users get&nbsp;online, requesting ever richer and more powerful &mdash;and thus computation intensive&mdash; services. This massive&nbsp;computation is increasingly shifted from the &ldquo;wimpy,&rdquo; battery-backed devices into the servers in the&nbsp;cloud. An extreme example is Google&rsquo;s Chrome OS, which provides only a web-browser interface to&nbsp;users and outsources almost all computation to the cloud. To cope with this massive computation, virtually&nbsp;all services today employ threads to increase performance, and likely they will in the foreseeable future.</p>\n<p>Unfortunately, despite our increasing reliance on multithreaded programs, they remain difficult&nbsp;to write, test, and debug, much more difficult than sequential programs. This difficulty leads&nbsp;to numerous insidious concurrency errors in many widespread multithreaded programs. These&nbsp;errors include data races, atomicity violations, and order violations, which we broadly define to be&nbsp;races. These races may cause &ldquo;mere&rdquo; application crashes, or worse, silent data corruptions, or even worse,&nbsp;deaths and the Northeast blackout in 2003. Multithreaded programs are the most widespread parallel&nbsp;programs, yetmany luminaries in computing consider parallel programming one of the top challenges&nbsp;facing computer science. Quoting John Hennessy: &ldquo;when we start talking about parallelism and ease of&nbsp;use of truly parallel computers, we&rsquo;re talking about a problem that&rsquo;s as hard as any that computer science has faced.&rdquo;&nbsp;</p>\n<p>To improve the reliability of multithreaded programs, a plethora of prior research has focused on race&nbsp;detection. However, detection of a race is only half of the battle. Developers&nbsp;must still diagnose the race reports to distill harmful races from false or benign ones. Moreover, developers&nbsp;must still fix the races.</p>\n<p>When it comes to race fix and diagnosis, developers are the bona fide solution. Unfortunately, little has&nbsp;been done to help developers fix and diagnose races. Existing race fix and diagnosis systems&nbsp;aim for full automation, an extremely challenging problem. To simplify the problem, existing systems&nbsp;unsurprisingly have to restrict themselves to a small, fixed set of race patterns, which cannot be extended&nbsp;by the rich domain knowledge of developers. Perhaps the most &ldquo;outrageous&rdquo; example is that, these tools&nbsp;do not work with order violations as simple as &ldquo;statement e1 must happen before statement e2 but the&nbsp;code fails to enforce so,&rdquo; because we do not yet have good automated detectors for these order violations.</p>\n<p>The research objective of this proposal is to&nbsp;<strong>create effective systems and technologies to help developers fix and&nbsp;</strong><strong>diagnose races</strong>. In our preliminary work, we have studied the fix and&nbsp;diagnosis process of real races and identified two key challenges yet to&nbsp;be addressed. First, how to help developers immediately protect&nbsp;<strong>deployed</strong>&nbsp;programs from known races? Even with the correct&nbsp;diagnosis of a race, fixing this race in a deployed program can still take&nbsp;long. This delay leaves large vulnerability windows, compromising reliability&nbsp;and potentially security. Second...",
  "por_txt_cntn": "\nTwo trends make multithreaded programs increasingly critical. The first is a hardware trend: the rise of multicore. For years, single-threaded code enjoyed automatic speedup as computer architects steadilymade single-coremultiprocessors faster. Recently, however, this \"free lunch is over\": power and wire-delay constraints have forced microprocessors into multicore designs, and adding more cores does not automatically speed up single-threaded code.\n\nThe second is a software trend: the coming storm of cloud computing. More and more users get online, requesting ever richer and more powerful &mdash;and thus computation intensive&mdash; services. This massive computation is increasingly shifted from the \"wimpy,\" battery-backed devices into the servers in the cloud. An extreme example is Google\u00c6s Chrome OS, which provides only a web-browser interface to users and outsources almost all computation to the cloud. To cope with this massive computation, virtually all services today employ threads to increase performance, and likely they will in the foreseeable future.\n\nUnfortunately, despite our increasing reliance on multithreaded programs, they remain difficult to write, test, and debug, much more difficult than sequential programs. This difficulty leads to numerous insidious concurrency errors in many widespread multithreaded programs. These errors include data races, atomicity violations, and order violations, which we broadly define to be races. These races may cause \"mere\" application crashes, or worse, silent data corruptions, or even worse, deaths and the Northeast blackout in 2003. Multithreaded programs are the most widespread parallel programs, yetmany luminaries in computing consider parallel programming one of the top challenges facing computer science. Quoting John Hennessy: \"when we start talking about parallelism and ease of use of truly parallel computers, we\u00c6re talking about a problem that\u00c6s as hard as any that computer science has faced.\" \n\nTo improve the reliability of multithreaded programs, a plethora of prior research has focused on race detection. However, detection of a race is only half of the battle. Developers must still diagnose the race reports to distill harmful races from false or benign ones. Moreover, developers must still fix the races.\n\nWhen it comes to race fix and diagnosis, developers are the bona fide solution. Unfortunately, little has been done to help developers fix and diagnose races. Existing race fix and diagnosis systems aim for full automation, an extremely challenging problem. To simplify the problem, existing systems unsurprisingly have to restrict themselves to a small, fixed set of race patterns, which cannot be extended by the rich domain knowledge of developers. Perhaps the most \"outrageous\" example is that, these tools do not work with order violations as simple as \"statement e1 must happen before statement e2 but the code fails to enforce so,\" because we do not yet have good automated detectors for these order violations.\n\nThe research objective of this proposal is to create effective systems and technologies to help developers fix and diagnose races. In our preliminary work, we have studied the fix and diagnosis process of real races and identified two key challenges yet to be addressed. First, how to help developers immediately protect deployed programs from known races? Even with the correct diagnosis of a race, fixing this race in a deployed program can still take long. This delay leaves large vulnerability windows, compromising reliability and potentially security. Second, how to help developers create the thread interleavings they want to test? When diagnosing a race or validating a \"race fix,\" developers often knows what thread interleavings may trigger the race. Unfortunately, they have no effective ways of forcing these interleavings, and often resort to strenuous, slow, and error-prone manual methods.\n\nTo fully achieve our goal, we have gone from \"soup to nuts\" in buildin..."
 }
}