{
 "awd_id": "1065166",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CCF: Medium: Validating Program Transformations in a Mechanized LLVM",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2011-07-01",
 "awd_exp_date": "2016-06-30",
 "tot_intn_awd_amt": 806961.0,
 "awd_amount": 806961.0,
 "awd_min_amd_letter_date": "2011-03-25",
 "awd_max_amd_letter_date": "2011-03-25",
 "awd_abstract_narration": "Because the safety, reliability, and performance of our computing infrastructure rests on the quality of its software, improving software quality is of prime importance for continuing the technological and social advances made possible by computers. Compilers, the primary tools used in constructing software, are therefore crucial--their correctness is essential if developers are to create new, usable software that is free from flaws that lead to crashes and susceptibility to malware.  This goal of this project is to provide a methodology for verifying the correctness of compiler transformations for modern computing platforms, emphasizing software designed to work on multicore architectures.\r\n\r\nThis research investigates techniques for building program transformation validators for the LLVM (Low-Level Virtual Machine) infrastructure, an open-source intermediate language used in industrial compilers. The researchers will define denotational semantics for symbolic evaluation of LLVM programs, and prove (in the interactive theorem prover Coq) that the interpretations of symbolic evaluation results are consistent with operational semantics.  To account for multi-core, shared-memory computer architectures, the project will define a concurrent memory model, parameterized by target architecture configurations, which promises sequential consistency for data race free programs.  This model's semantics will be expressive enough to represent program behaviors, and suitable for mechanized proofs. If successful, this research will decrease the cost of developing and testing compilers, and improve our understanding of the programming language implementations, particularly on multi-core processors, thereby leading to a more reliable, secure, and cost-effective computing ecosystem.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Stephan",
   "pi_last_name": "Zdancewic",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Stephan A Zdancewic",
   "pi_email_addr": "stevez@cis.upenn.edu",
   "nsf_id": "000220116",
   "pi_start_date": "2011-03-25",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Pennsylvania",
  "inst_street_address": "3451 WALNUT ST STE 440A",
  "inst_street_address_2": "",
  "inst_city_name": "PHILADELPHIA",
  "inst_state_code": "PA",
  "inst_state_name": "Pennsylvania",
  "inst_phone_num": "2158987293",
  "inst_zip_code": "191046205",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "PA03",
  "org_lgl_bus_name": "TRUSTEES OF THE UNIVERSITY OF PENNSYLVANIA, THE",
  "org_prnt_uei_num": "GM1XX56LEP58",
  "org_uei_num": "GM1XX56LEP58"
 },
 "perf_inst": {
  "perf_inst_name": "University of Pennsylvania",
  "perf_str_addr": "3451 WALNUT ST STE 440A",
  "perf_city_name": "PHILADELPHIA",
  "perf_st_code": "PA",
  "perf_st_name": "Pennsylvania",
  "perf_zip_code": "191046205",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "PA03",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 806961.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The Low-Level Virtual Machine (LLVM) infrastructure is a critical component that is widely used by&nbsp;software developers, including Microsoft, Google, and, most prominently, Apple. &nbsp;</p>\n<p>This reseach project developed techniques and methodologies capabable of eliminating certain kinds of bugs and vulnerabilities from the LLVM infrastructure and the tools that use it. &nbsp;The approach was to develop a faithful mathematical model of the LLVM infrastructure and then use that mathematical model to verify that various ways of processing LLVM code are correct. &nbsp;Because the mathematical model and corresponding proofs are large, the researchers employed machine-checked interactive theorem provers (essentially software that helps create mathematical models).</p>\n<p>The fundamental results of this project yield new techniques for developing reliable software. &nbsp;A primary case study, called SoftBound, conducted as part of this research demonstrated how to implement a formally-verified program transformation that defends legacy C software against buffer-overflow attacks, which are among the most serious kinds of software vulnerabilities in today's Internet. &nbsp;</p>\n<p>Beyond numerous academic publications, this research has also contributed to the development of two significant software artifacts. &nbsp;The first, SoftBound, is a tool available to LLVM developers as part of the LLVM distribution that they can use to harden C programs against buffer overflow attacks. &nbsp;The second, Vellvm is the interactive theorem proving development that can be used to model and reason about LLVM programs. &nbsp;It is being used by several research groups from around the world.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 08/24/2016<br>\n\t\t\t\t\tModified by: Stephan&nbsp;A&nbsp;Zdancewic</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe Low-Level Virtual Machine (LLVM) infrastructure is a critical component that is widely used by software developers, including Microsoft, Google, and, most prominently, Apple.  \n\nThis reseach project developed techniques and methodologies capabable of eliminating certain kinds of bugs and vulnerabilities from the LLVM infrastructure and the tools that use it.  The approach was to develop a faithful mathematical model of the LLVM infrastructure and then use that mathematical model to verify that various ways of processing LLVM code are correct.  Because the mathematical model and corresponding proofs are large, the researchers employed machine-checked interactive theorem provers (essentially software that helps create mathematical models).\n\nThe fundamental results of this project yield new techniques for developing reliable software.  A primary case study, called SoftBound, conducted as part of this research demonstrated how to implement a formally-verified program transformation that defends legacy C software against buffer-overflow attacks, which are among the most serious kinds of software vulnerabilities in today's Internet.  \n\nBeyond numerous academic publications, this research has also contributed to the development of two significant software artifacts.  The first, SoftBound, is a tool available to LLVM developers as part of the LLVM distribution that they can use to harden C programs against buffer overflow attacks.  The second, Vellvm is the interactive theorem proving development that can be used to model and reason about LLVM programs.  It is being used by several research groups from around the world.\n\n\t\t\t\t\tLast Modified: 08/24/2016\n\n\t\t\t\t\tSubmitted by: Stephan A Zdancewic"
 }
}