{
 "awd_id": "1116725",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Reversible Concurrency",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2011-08-01",
 "awd_exp_date": "2014-07-31",
 "tot_intn_awd_amt": 317477.0,
 "awd_amount": 317477.0,
 "awd_min_amd_letter_date": "2011-07-07",
 "awd_max_amd_letter_date": "2012-12-21",
 "awd_abstract_narration": "We face a future in which computational resources at the processor level are \"free\" with hundreds or thousands of cores, yet we have little idea how to utilize these resources except for well-structured and highly parallel applications.  This research aims, in the long term, to provide programmers with the same computing power that Nature exploits to seemingly solve difficult problems efficiently.  The dominant programming model in Nature is that of a massive number of \"cheap\" computing elements collaborating by message passing.  One such strategy to solving complex problems is to speculatively pursue many possible solutions in parallel, discarding (partial) computations that lack promise or violate necessary constraints.  Unfortunately concurrent speculative algorithms are challenging to develop because of the intermingling of execution paths with concurrency and communication.  The goal of this project is to take significant steps towards a theory of speculation for concurrent algorithms and to develop an experimental framework for their development.  This research will enable the study of novel applications to utilize the vast computational resources that future processors seem destined to provide.\r\n\r\nThis project is inspired and informed by recent work on reversible computing which is itself inspired by reversibility in the laws of Physics.  Research on reversible concurrency, while illuminating key properties that a system must satisfy (e.g. causal unwinding of communication), has neither yielded models that can reasonably be implemented in a distributed environment nor provided necessary details for a practical language.  This project will develop concurrent programming languages that support explicit speculation in concurrent systems using the ideas from reversible concurrent programming to factor out the mechanisms used to realize speculation from speculative algorithms. The project will also leverage ideas from backtracking monad and monad transformers to isolate the interactions between speculation and computation effects including communication, and ideas from process algebras to develop a model for understanding language constructs supporting speculative execution. The research includes experimental work to implement and test linguistic constructs and theoretical work to provide both formal models for these constructs, and algebraic tools to enable reasoning about programs that utilize them.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Amr",
   "pi_last_name": "Sabry",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Amr A Sabry",
   "pi_email_addr": "sabry@iu.edu",
   "nsf_id": "000492966",
   "pi_start_date": "2011-07-07",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Co-Principal Investigator",
   "pi_first_name": "Geoffrey",
   "pi_last_name": "Brown",
   "pi_mid_init": "M",
   "pi_sufx_name": "",
   "pi_full_name": "Geoffrey M Brown",
   "pi_email_addr": "geobrown@indiana.edu",
   "nsf_id": "000258883",
   "pi_start_date": "2011-07-07",
   "pi_end_date": "2012-12-21"
  }
 ],
 "inst": {
  "inst_name": "Indiana University",
  "inst_street_address": "107 S INDIANA AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BLOOMINGTON",
  "inst_state_code": "IN",
  "inst_state_name": "Indiana",
  "inst_phone_num": "3172783473",
  "inst_zip_code": "474057000",
  "inst_country_name": "United States",
  "cong_dist_code": "09",
  "st_cong_dist_code": "IN09",
  "org_lgl_bus_name": "TRUSTEES OF INDIANA UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "YH86RTW2YVJ4"
 },
 "perf_inst": {
  "perf_inst_name": "Indiana University",
  "perf_str_addr": "107 S INDIANA AVE",
  "perf_city_name": "BLOOMINGTON",
  "perf_st_code": "IN",
  "perf_st_name": "Indiana",
  "perf_zip_code": "474057000",
  "perf_ctry_code": "US",
  "perf_cong_dist": "09",
  "perf_st_cong_dist": "IN09",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 317477.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><br />Speculative execution either by intent or through misfortune (in response to<br />error conditions) is pervasive in system design and yet it remains difficult<br />to handle at the program level.&nbsp; The state of the art in \"speculative<br />distributed computing\" is that:<br /><br />* speculation is the norm in practical distributed algorithms;<br /><br />* speculative algorithms are intricate to write and hard to reason about<br />because speculative computations usually intermingle the various execution<br />paths with concurrency and communication in an unprincipled way;<br /><br />* a theory of speculation should tease apart these various<br />aspects. Specifically the speculation, the speculative algorithm, and its<br />backup should all be first class separate citizens of a distributed<br />computation.<br /><br />We find that despite the importance of speculative computation, there is very<br />little programmatic support for it in distributed languages at the<br />foundational level it deserves. From a programming language perspective,<br />speculative execution requires a backtracking mechanism. Even in the<br />sequential case, backtracking in the presence of various computational<br />effects (e.g. assignments, exceptions, etc.) has significant subtleties. The<br />introduction of concurrency additionally requires a \"distributed<br />backtracking\" algorithm that must \"undo\" the effects of any communication<br />events that occurred in the scope over which we wish to backtrack.<br /><br />In this project, we introduced a programming model for a distributed language<br />with message-passing concurrency that treats \"speculation\" as a first class<br />construct. The focus on message-passing concurrency is justified by the<br />emergence of massively parallel multicore processors with high-bandwidth<br />message passing. In this domain, speculative execution can be used to<br />eliminate sequential bottlenecks by performing work ahead of synchronization<br />constraints and discarding this speculative work if it violates consistency<br />requirements. <br /><br />The key contributions of this project are a protocol for handling<br />point-to-point synchronous communication that enables a clean implementation<br />of scoped rollback in a distributed program; a formal model of the protocol<br />with automated verification; and the design of a high-level concurrent<br />reversible language that embodies this protocol and its implementation in<br />Scala.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/05/2014<br>\n\t\t\t\t\tModified by: Amr&nbsp;A&nbsp;Sabry</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n\nSpeculative execution either by intent or through misfortune (in response to\nerror conditions) is pervasive in system design and yet it remains difficult\nto handle at the program level.  The state of the art in \"speculative\ndistributed computing\" is that:\n\n* speculation is the norm in practical distributed algorithms;\n\n* speculative algorithms are intricate to write and hard to reason about\nbecause speculative computations usually intermingle the various execution\npaths with concurrency and communication in an unprincipled way;\n\n* a theory of speculation should tease apart these various\naspects. Specifically the speculation, the speculative algorithm, and its\nbackup should all be first class separate citizens of a distributed\ncomputation.\n\nWe find that despite the importance of speculative computation, there is very\nlittle programmatic support for it in distributed languages at the\nfoundational level it deserves. From a programming language perspective,\nspeculative execution requires a backtracking mechanism. Even in the\nsequential case, backtracking in the presence of various computational\neffects (e.g. assignments, exceptions, etc.) has significant subtleties. The\nintroduction of concurrency additionally requires a \"distributed\nbacktracking\" algorithm that must \"undo\" the effects of any communication\nevents that occurred in the scope over which we wish to backtrack.\n\nIn this project, we introduced a programming model for a distributed language\nwith message-passing concurrency that treats \"speculation\" as a first class\nconstruct. The focus on message-passing concurrency is justified by the\nemergence of massively parallel multicore processors with high-bandwidth\nmessage passing. In this domain, speculative execution can be used to\neliminate sequential bottlenecks by performing work ahead of synchronization\nconstraints and discarding this speculative work if it violates consistency\nrequirements. \n\nThe key contributions of this project are a protocol for handling\npoint-to-point synchronous communication that enables a clean implementation\nof scoped rollback in a distributed program; a formal model of the protocol\nwith automated verification; and the design of a high-level concurrent\nreversible language that embodies this protocol and its implementation in\nScala.\n\n\t\t\t\t\tLast Modified: 11/05/2014\n\n\t\t\t\t\tSubmitted by: Amr A Sabry"
 }
}