{
 "awd_id": "1116551",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Single Assignment Architecture / Single Assignment Compiler",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927498",
 "po_email": "achtchel@nsf.gov",
 "po_sign_block_name": "Almadena Chtchelkanova",
 "awd_eff_date": "2011-08-01",
 "awd_exp_date": "2013-07-31",
 "tot_intn_awd_amt": 153000.0,
 "awd_amount": 153000.0,
 "awd_min_amd_letter_date": "2011-07-13",
 "awd_max_amd_letter_date": "2011-07-13",
 "awd_abstract_narration": "Today, practically all processors employ instruction set architectures which are functionally\r\nequivalent to each other. Compiler/micro-architecture cooperation using these traditional\r\nrepresentations has already reached the point of diminishing returns. This project therefore\r\ninvestigates the domain of single assignment program representations and direct support of this\r\ndomain through micro-architecture implementation as a key concept that can break the barriers\r\nbetween the compilers and architectures.  If successful, this new approach can have a significant\r\nimpact on the design of future processors, design of compiler internal representations as well as\r\nthe back-end of the compilers. It can also affect how parallelism is exploited at various\r\ngranularities and how various optimizations are carried out.  The investigated framework can help\r\nrevitalize computer architecture and compiler optimization research by opening up unexplored paths\r\nfor research in high-performance systems.  Consequently, it can affect every field of science and\r\ncommerce which rely on high-performance computation. \r\n\r\nCompiler/hardware integration around the concept of single-assignment form has many benefits\r\nspanning three fields. First, in the area of process synchronization it provides the opportunity to\r\neliminate the need for explicit synchronization. Second, in the field of micro-architecture renaming\r\nof instruction streams becomes substantially simpler, micro-architectures can become loop-aware,\r\nrenamed instruction streams can be re-renamed and compiler techniques such as partial redundancy\r\nelimination or constant propagation can dynamically be performed by the micro-architecture.\r\nFinally, the compilers can focus on what they do best by sharing a common representation with the\r\nmicro-architecture. As a result, many key optimizations can be efficiently performed. Within\r\nthis paradigm, it becomes possible to develop new optimization algorithms which will rely on the\r\nmicro-architecture to perform the optimization using analysis performed by the compilers.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Soner",
   "pi_last_name": "Onder",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Soner Onder",
   "pi_email_addr": "soner@mtu.edu",
   "nsf_id": "000207375",
   "pi_start_date": "2011-07-13",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Michigan Technological University",
  "inst_street_address": "1400 TOWNSEND DR",
  "inst_street_address_2": "",
  "inst_city_name": "HOUGHTON",
  "inst_state_code": "MI",
  "inst_state_name": "Michigan",
  "inst_phone_num": "9064871885",
  "inst_zip_code": "499311200",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "MI01",
  "org_lgl_bus_name": "MICHIGAN TECHNOLOGICAL UNIVERSITY",
  "org_prnt_uei_num": "GKMSN3DA6P91",
  "org_uei_num": "GKMSN3DA6P91"
 },
 "perf_inst": {
  "perf_inst_name": "Michigan Technological University",
  "perf_str_addr": "1400 TOWNSEND DR",
  "perf_city_name": "HOUGHTON",
  "perf_st_code": "MI",
  "perf_st_name": "Michigan",
  "perf_zip_code": "499311200",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "MI01",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7329",
   "pgm_ref_txt": "COMPILERS"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 153000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The current industrial trend for enhancing computer performance is to offer processors with multiple cores due to technological constraints which prevent higher clock speeds at reasonable power consumption levels. While they provide increased throughput, multi-core processors require parallel programs to take advantage of their processing capability. Through this grant, we have developed new execution models which can remove several existing barriers in exploiting parallelism from a sequential program. These models rely on a single program representation that is used by the compilers as well as the processor itself. The most promising execution model we have developed is demand-driven execution of imperative programs. Demand-driven execution starts from the outputs of a program, progressing towards its inputs and finds all instructions eligible for execution in a parallel fashion during the process. Although demand-driven execution models have been tried in the past, these prior attempts worked only with functional programs, whereas the dominant programming languages used by the software industry today are imperative programing languages such as Java or C.<br /><br />Our developed techniques will make demand-driven processors capable of executing programs written in these languages efficiently. Our work indicates that these demand-driven processors can be built by using many parallel processor cores just like existing processors. However, unlike existing processors, they can collaboratively speed-up the execution speed of a single program without developing a parallel version of the program.</p>\n<p><br />Although this one year grant provided a much needed support for the initial forming and testing of the ideas, additional effort is still necessary before we can bring these models to a level that the industry can take over to implement these ideas in actual processors.&nbsp; This grant has provided partial support for three PhD students and a MSc student and helped them progress towards their degrees. Doing so, it has contributed to the nation's future work force who can advance the frontiers of science.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/28/2013<br>\n\t\t\t\t\tModified by: Soner&nbsp;Onder</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe current industrial trend for enhancing computer performance is to offer processors with multiple cores due to technological constraints which prevent higher clock speeds at reasonable power consumption levels. While they provide increased throughput, multi-core processors require parallel programs to take advantage of their processing capability. Through this grant, we have developed new execution models which can remove several existing barriers in exploiting parallelism from a sequential program. These models rely on a single program representation that is used by the compilers as well as the processor itself. The most promising execution model we have developed is demand-driven execution of imperative programs. Demand-driven execution starts from the outputs of a program, progressing towards its inputs and finds all instructions eligible for execution in a parallel fashion during the process. Although demand-driven execution models have been tried in the past, these prior attempts worked only with functional programs, whereas the dominant programming languages used by the software industry today are imperative programing languages such as Java or C.\n\nOur developed techniques will make demand-driven processors capable of executing programs written in these languages efficiently. Our work indicates that these demand-driven processors can be built by using many parallel processor cores just like existing processors. However, unlike existing processors, they can collaboratively speed-up the execution speed of a single program without developing a parallel version of the program.\n\n\nAlthough this one year grant provided a much needed support for the initial forming and testing of the ideas, additional effort is still necessary before we can bring these models to a level that the industry can take over to implement these ideas in actual processors.  This grant has provided partial support for three PhD students and a MSc student and helped them progress towards their degrees. Doing so, it has contributed to the nation's future work force who can advance the frontiers of science.\n\n\t\t\t\t\tLast Modified: 10/28/2013\n\n\t\t\t\t\tSubmitted by: Soner Onder"
 }
}