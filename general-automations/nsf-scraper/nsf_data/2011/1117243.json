{
 "awd_id": "1117243",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Software and Hardware Integration with Feedback and Transparency for Many-Core Computing",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927498",
 "po_email": "achtchel@nsf.gov",
 "po_sign_block_name": "Almadena Chtchelkanova",
 "awd_eff_date": "2011-09-01",
 "awd_exp_date": "2013-08-31",
 "tot_intn_awd_amt": 139846.0,
 "awd_amount": 139846.0,
 "awd_min_amd_letter_date": "2011-07-19",
 "awd_max_amd_letter_date": "2011-07-19",
 "awd_abstract_narration": "Multi-core processors are becoming prevalent and provide means for continuing to increase our computational capacity. These emerging platforms with multiple processing cores on chip offer the capability to run multiple programs simultaneously, thereby increasing the processing power of computing systems. However, since the running programs often share multi-core resources, execution interference effects between such programs can hurt their performance. Often times, software obliviousness to this underlying hardware behavior exacerbate the multi-core performance problem. Such adverse effects limit our computational progress in areas where interference can be detrimental such as high-performance computing and cloud computing, and could further complicate the predictability and deployment of these advanced processors in mission-critical domains such as avionics and automobiles. Therefore, understanding software behavior and Interference effects on multi-core processors is crucial to harnessing their full potential.\r\n\r\nIn this research the investigators do preliminary studies of the issues arising from execution interference between multiple software threads on multi-core processor platforms. This research involves revisiting how hardware resource management can account for application-level constraints (such as performance isolation, fairness, and priority) by enhancing the interface between hardware and the Operating System (OS), and studying the hardware and software overheads. This research lays the groundwork for the hardware-OS interaction based on active fine-grained monitoring of resources and a two-way adaptation between both the hardware and OS to tightly control the effects of interference between threads.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Guru Prasadh",
   "pi_last_name": "Venkataramani",
   "pi_mid_init": "V",
   "pi_sufx_name": "",
   "pi_full_name": "Guru Prasadh V Venkataramani",
   "pi_email_addr": "guruv@gwu.edu",
   "nsf_id": "000580837",
   "pi_start_date": "2011-07-19",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Gabriel",
   "pi_last_name": "Parmer",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Gabriel A Parmer",
   "pi_email_addr": "gparmer@gwu.edu",
   "nsf_id": "000560657",
   "pi_start_date": "2011-07-19",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "George Washington University",
  "inst_street_address": "1918 F ST NW",
  "inst_street_address_2": "",
  "inst_city_name": "WASHINGTON",
  "inst_state_code": "DC",
  "inst_state_name": "District of Columbia",
  "inst_phone_num": "2029940728",
  "inst_zip_code": "200520042",
  "inst_country_name": "United States",
  "cong_dist_code": "00",
  "st_cong_dist_code": "DC00",
  "org_lgl_bus_name": "GEORGE WASHINGTON UNIVERSITY (THE)",
  "org_prnt_uei_num": "",
  "org_uei_num": "ECR5E2LU5BL6"
 },
 "perf_inst": {
  "perf_inst_name": "George Washington University",
  "perf_str_addr": "1918 F ST NW",
  "perf_city_name": "WASHINGTON",
  "perf_st_code": "DC",
  "perf_st_name": "District of Columbia",
  "perf_zip_code": "200520042",
  "perf_ctry_code": "US",
  "perf_cong_dist": "00",
  "perf_st_cong_dist": "DC00",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7329",
   "pgm_ref_txt": "COMPILERS"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 139846.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>For decades now, the basic interaction between hardware and software has remained unchanged: the OS (operating systems) handles the execution of multiple applications, and assumes that smart compilers know how best to exploit hardware resources efficiently. It is often assumed that, as hardware capabilities increase -- with faster processors, and ever increasing numbers of computing cores -- applications will trivially take advantage of the turbo-charged hardware by merely choosing an application to execute (i.e. schedule it) and &ldquo;getting out of the way&rdquo;. Unfortunately, such an approach on modern-day computing platforms like multi-core chips, results in performance artifacts and degradations as applications on different cores interfere with each other and contend for shared hardware resources. &nbsp;It is essential to effectively harness the potential resulting from increasing core counts and continue the progress that computers have enjoyed over the past several decades. &nbsp;This requires a closer collaboration between software and hardware than has traditionally been customary.</p>\n<p><br />In this project, the Principal Investigators (PIs) and their research groups have performed preliminary studies to better understand execution interference between multiple software computations running on multi-core processor platforms, and have produced research publications that aim to bridge the significant gap between software and hardware.</p>\n<p><br />First, the PIs have investigated the impact of how execution on different cores impacts the system's consumption of power. Experimental studies show that even after balancing performance on various cores, the power consumption by the respective cores could still vary. Such variations are a result of differences in application code executing on the chip, execution time artifacts resulting from minor variations in the underlying core microarchitecture and so on. This disparity in power consumption both drains batteries faster and affects the processor's heat density -- making it hard to leverage the multi-core processors in most computing environments including mobile platforms. This result has a significant influence on how a programmer writes and tests their programs; in addition to making sure that programs are functionally correct, they must keep track of an application's power consumption behavior. &nbsp;This project has highlighted the need for understanding power in multi-core applications and their interactions with the processor micro-architecture.</p>\n<p><br />Second, the PIs have researched a novel software architecture that is capable of much finer-grained interactions with hardware. &nbsp;A typical software system is composed of code with large numbers of different patterns and means for using the hardware. &nbsp;The PI's architecture decouples software with different \"hardware finger-prints\" into disparate components, and opens the possibility for a better matching of components with specific requirements, to hardware that best accommodates those needs. &nbsp;Components, though beneficial for isolating software with specific requirements, also raise challenges that the PIs address. &nbsp;For example, to break software systems into components requires effective and efficient means for them to communicate with each other, a focus of this work. &nbsp;By creating a novel software architecture based on components, the PIs have enabled the potential for a more effective mapping of specialized software to comparably specialized hardware to effectively bridge the gap between hardware and software.</p>\n<p><br />The PIs have also integrated this research with educational initiatives by engaging students at The George Washington University in this research, and by integrating the insights regarding delicate interplay between software and hardware into the GWU undergraduate and graduate courses on computer ar...",
  "por_txt_cntn": "\nFor decades now, the basic interaction between hardware and software has remained unchanged: the OS (operating systems) handles the execution of multiple applications, and assumes that smart compilers know how best to exploit hardware resources efficiently. It is often assumed that, as hardware capabilities increase -- with faster processors, and ever increasing numbers of computing cores -- applications will trivially take advantage of the turbo-charged hardware by merely choosing an application to execute (i.e. schedule it) and \"getting out of the way\". Unfortunately, such an approach on modern-day computing platforms like multi-core chips, results in performance artifacts and degradations as applications on different cores interfere with each other and contend for shared hardware resources.  It is essential to effectively harness the potential resulting from increasing core counts and continue the progress that computers have enjoyed over the past several decades.  This requires a closer collaboration between software and hardware than has traditionally been customary.\n\n\nIn this project, the Principal Investigators (PIs) and their research groups have performed preliminary studies to better understand execution interference between multiple software computations running on multi-core processor platforms, and have produced research publications that aim to bridge the significant gap between software and hardware.\n\n\nFirst, the PIs have investigated the impact of how execution on different cores impacts the system's consumption of power. Experimental studies show that even after balancing performance on various cores, the power consumption by the respective cores could still vary. Such variations are a result of differences in application code executing on the chip, execution time artifacts resulting from minor variations in the underlying core microarchitecture and so on. This disparity in power consumption both drains batteries faster and affects the processor's heat density -- making it hard to leverage the multi-core processors in most computing environments including mobile platforms. This result has a significant influence on how a programmer writes and tests their programs; in addition to making sure that programs are functionally correct, they must keep track of an application's power consumption behavior.  This project has highlighted the need for understanding power in multi-core applications and their interactions with the processor micro-architecture.\n\n\nSecond, the PIs have researched a novel software architecture that is capable of much finer-grained interactions with hardware.  A typical software system is composed of code with large numbers of different patterns and means for using the hardware.  The PI's architecture decouples software with different \"hardware finger-prints\" into disparate components, and opens the possibility for a better matching of components with specific requirements, to hardware that best accommodates those needs.  Components, though beneficial for isolating software with specific requirements, also raise challenges that the PIs address.  For example, to break software systems into components requires effective and efficient means for them to communicate with each other, a focus of this work.  By creating a novel software architecture based on components, the PIs have enabled the potential for a more effective mapping of specialized software to comparably specialized hardware to effectively bridge the gap between hardware and software.\n\n\nThe PIs have also integrated this research with educational initiatives by engaging students at The George Washington University in this research, and by integrating the insights regarding delicate interplay between software and hardware into the GWU undergraduate and graduate courses on computer architecture and operating systems. Additionally, the PIs have mentored seniors in their capstone projects, efforts which have resulted in published research wi..."
 }
}