{
 "awd_id": "1117135",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CSR: Small: Fluid Communication for Parallel Programs",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2011-08-01",
 "awd_exp_date": "2013-07-31",
 "tot_intn_awd_amt": 199967.0,
 "awd_amount": 214967.0,
 "awd_min_amd_letter_date": "2011-07-22",
 "awd_max_amd_letter_date": "2012-04-18",
 "awd_abstract_narration": "Every aspect of parallel software development is more complicated than for\r\nserial programs.  This research focuses on one of the primary sources of\r\ncomplexity: intra-application communication.  Currently it is a programmer's\r\nresponsibility to find an efficient mapping of their application's\r\ncommunication patterns onto the communication infrastructure of the target\r\nsystem.  This research flips that responsibility by developing a flexible\r\ncommunication architecture and associated tools and algorithms that allow the\r\ntarget platform to be specialized for a particular application, rather than\r\nvice versa.  In addition to reducing the programmer's burden, specialization\r\nhas the potential to improve communication efficiency while the automated\r\ntechniques can increase portability.  \r\n\r\nThis research poses questions whose answers have consequences at several\r\nlevels of the traditional system stack: Can programmers be freed from\r\nhardware-specific optimization of communication without degrading performance?\r\nWhat abstractions are needed to allow hardware to adapt to the programmer,\r\nrather than the other way around?  Can communication efficiency be improved\r\nwhen running on an application-specific communication platform?  The project\r\nanswers these questions by exploring abstractions and algorithms to profile a\r\nparallel program's communication, synthesize a custom network design, and\r\nimplement it in a configurable network architecture substrate.  The research\r\nmethods center around the X10 language, and include compiler instrumentation\r\npasses, offline communication profile analyses, development of a portable\r\nnetwork intermediate representation, and network place and route software\r\nalgorithms.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Martha",
   "pi_last_name": "Kim",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Martha A Kim",
   "pi_email_addr": "martha@cs.columbia.edu",
   "nsf_id": "000528915",
   "pi_start_date": "2011-07-22",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Columbia University",
  "inst_street_address": "615 W 131ST ST",
  "inst_street_address_2": "MC 8741",
  "inst_city_name": "NEW YORK",
  "inst_state_code": "NY",
  "inst_state_name": "New York",
  "inst_phone_num": "2128546851",
  "inst_zip_code": "100277922",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "NY13",
  "org_lgl_bus_name": "THE TRUSTEES OF COLUMBIA UNIVERSITY IN THE CITY OF NEW YORK",
  "org_prnt_uei_num": "",
  "org_uei_num": "F4N1QNPB95M4"
 },
 "perf_inst": {
  "perf_inst_name": "Columbia University",
  "perf_str_addr": "615 W 131ST ST",
  "perf_city_name": "NEW YORK",
  "perf_st_code": "NY",
  "perf_st_name": "New York",
  "perf_zip_code": "100277922",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "NY13",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "171400",
   "pgm_ele_name": "Special Projects - CNS"
  },
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7354",
   "pgm_ref_txt": "COMPUTER SYSTEMS"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9178",
   "pgm_ref_txt": "UNDERGRADUATE EDUCATION"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 199967.0
  },
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 15000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p class=\"p1\">In order to make efficient use of modern computing hardware, it is often necessary for software to be parallelized. &nbsp;Parallelization can often be challenging, particularly with respect to understanding a program's runtime behavior and diagnosing correctness and performance problems. &nbsp;The goal of this project was to develop and apply a new perspective from which to analyze a parallel program's execution.&nbsp;</p>\n<p class=\"p2\">&nbsp;</p>\n<p class=\"p1\">As a result of this award, we have developed the concept of a parallel block vector profile. &nbsp;This profile&nbsp;considers an application in fragments called basic blocks, revealing the degree of parallelism exhibited by the application, i.e., the number of parallel threads, each time each basic block is executed. &nbsp;There are a number of ways to exploit this information. &nbsp;For example, we have analyzed applications on a per-fragment basis, and found, contrary to prevalent models, that basic blocks do not always belong exclusively to the serial or parallel regions of an application. &nbsp;A second analysis, explored the scalability of an application on a per-block basis, a much finer granularity than has been previously explored. &nbsp;A third use would be in conjunction with a timing model, to help reveal hidden performance bottlenecks. &nbsp;Because a parallel block vector profile simply reveals information, its uses are potentially both numerous and varied.</p>\n<p class=\"p2\">&nbsp;</p>\n<p class=\"p1\">A second outcome of this award was the development and release of an open source tool, called Harmony, which can be used to collect parallel block vector profiles. &nbsp;Collecting the fine-grained information demanded by the profiles without incurring substantial overhead is a non-trivial endeavor, and Harmony has been carefully designed and optimize to minimize any perturbation to the application under measurement.</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/03/2013<br>\n\t\t\t\t\tModified by: Martha&nbsp;A&nbsp;Kim</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "In order to make efficient use of modern computing hardware, it is often necessary for software to be parallelized.  Parallelization can often be challenging, particularly with respect to understanding a program's runtime behavior and diagnosing correctness and performance problems.  The goal of this project was to develop and apply a new perspective from which to analyze a parallel program's execution. \n \nAs a result of this award, we have developed the concept of a parallel block vector profile.  This profile considers an application in fragments called basic blocks, revealing the degree of parallelism exhibited by the application, i.e., the number of parallel threads, each time each basic block is executed.  There are a number of ways to exploit this information.  For example, we have analyzed applications on a per-fragment basis, and found, contrary to prevalent models, that basic blocks do not always belong exclusively to the serial or parallel regions of an application.  A second analysis, explored the scalability of an application on a per-block basis, a much finer granularity than has been previously explored.  A third use would be in conjunction with a timing model, to help reveal hidden performance bottlenecks.  Because a parallel block vector profile simply reveals information, its uses are potentially both numerous and varied.\n \nA second outcome of this award was the development and release of an open source tool, called Harmony, which can be used to collect parallel block vector profiles.  Collecting the fine-grained information demanded by the profiles without incurring substantial overhead is a non-trivial endeavor, and Harmony has been carefully designed and optimize to minimize any perturbation to the application under measurement.\n\n \n\n\t\t\t\t\tLast Modified: 11/03/2013\n\n\t\t\t\t\tSubmitted by: Martha A Kim"
 }
}