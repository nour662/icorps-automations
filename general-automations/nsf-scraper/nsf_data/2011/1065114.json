{
 "awd_id": "1065114",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CSR: Medium: Collaborative Research: Programming parallel in-memory data-center applications with Piccolo",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2011-07-01",
 "awd_exp_date": "2015-06-30",
 "tot_intn_awd_amt": 330171.0,
 "awd_amount": 330171.0,
 "awd_min_amd_letter_date": "2011-06-14",
 "awd_max_amd_letter_date": "2013-07-05",
 "awd_abstract_narration": "There is a rising demand to scale application performance by distributing \r\ncomputation across many machines in a data-center. It is difficult to write \r\nefficient and robust parallel programs in the data-center setting because \r\nprogrammers need to worry about reducing communication overhead while handling \r\npossible machine failures. \r\n\r\nThis project investigates a new data-centric parallel programming \r\nmodel, called Piccolo, that can simplify the construction of in-memory \r\ndata-center applications such as PageRank, neural network training etc. \r\n\r\nIn-memory applications can hold all their intermediate states in the aggregate \r\nmemory of many machines and benefit from sharing these intermediate states \r\nbetween machines during computation. Traditionally, these applications \r\nhave been built using low-level communication-centric primitives such as MPI, \r\nresulting in significant programming complexity. The recently popular \r\nMapReduce and Dryad also do not fit well with these applications \r\nbecause their data flow programming model lacks support for shared states. \r\n\r\nUnlike data flow models, Piccolo explicitly supports the sharing of mutable, \r\ndistributed states via a key/value table interface. Piccolo makes sharing \r\nefficient by optimizing for locality of access to shared tables and \r\nautomatically resolving write-write conflicts using user-defined accumulation \r\nfunctions. As a result, Piccolo is easy to program for, enables applications \r\nthat do not fit into MapReduce, and achieves good scalable performance.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Marinus",
   "pi_last_name": "Kaashoek",
   "pi_mid_init": "F",
   "pi_sufx_name": "",
   "pi_full_name": "Marinus F Kaashoek",
   "pi_email_addr": "kaashoek@lcs.mit.edu",
   "nsf_id": "000098539",
   "pi_start_date": "2011-06-14",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Massachusetts Institute of Technology",
  "inst_street_address": "77 MASSACHUSETTS AVE",
  "inst_street_address_2": "",
  "inst_city_name": "CAMBRIDGE",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6172531000",
  "inst_zip_code": "021394301",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY",
  "org_prnt_uei_num": "E2NYLCDML6V1",
  "org_uei_num": "E2NYLCDML6V1"
 },
 "perf_inst": {
  "perf_inst_name": "Massachusetts Institute of Technology",
  "perf_str_addr": "77 MASSACHUSETTS AVE",
  "perf_city_name": "CAMBRIDGE",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021394301",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7354",
   "pgm_ref_txt": "COMPUTER SYSTEMS"
  },
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 215781.0
  },
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 114390.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>In the era of ``Big Data'', many programmers whose backgrounds are not in computer science (e.g. business, natural and social sciences) wish to process an enormous amount of data using thousands of machines in the cloud. &nbsp;However, it is extraordinarily difficult to write programs that run on many machines, even for expert programmers who are well trained in programming distributed systems. &nbsp;The goal of this project is to develop programming and storage infrastructures that can hide the complexities of distribution and simplify the task of writing distributed applications. &nbsp;</p>\n<p><br />Distributed programming frameworks make it easy to write large-scale offline batch computation, such as text analytic, machine learning algorithms etc. &nbsp;Prior to this project's work, the state-of-the-art distributed programming framework was Google's MapReduce (and its open-source clone, Hadoop). &nbsp;While MapReduce works well for large-scale text processing, it is a bad fit for large classes of important applications in machine learning, scientific computing and computational biology. &nbsp;These applications can hold all their intermediate state in memory and need to share this intermediate state between machines during computation. &nbsp;As MapReduce lacks support for distributed state, it is awkward and inefficient to write these applications in MapReduce. &nbsp;This project has developed the Piccolo programming framework for these stateful, in-memory applications. &nbsp;To better support in-memory computation, Piccolo explicitly provides the sharing of mutable, distributed state across machines via a key/value table interface. &nbsp;Piccolo makes sharing efficient by providing simple primitives that programmers can use to optimize for locality of access to shared tables and to resolve write-write conflicts using user-defined accumulation functions. &nbsp;As a result, it is easy to program in Piccolo, and it enables applications that are not handled well by MapReduce.&nbsp;</p>\n<p>Piccolo is designed and built for a cluster of CPU machines. &nbsp;With the recent explosion of interests in deep neural networks, there is a surging demand for distributing expensive neural network training across many GPU machines. &nbsp;We have developed the Skynet distributed training system to investigate the challenges and scalability limits of distributed neural network training. &nbsp;We have found that the simple synchronous stochastic gradient descent strategy used by Skynet performs well up to a dozen GPU machines.</p>\n<p>Apart from offline batch computation (such as PageRank, neural network training), another important class of applications is web applications, characterized by their online storage-intensive workloads. &nbsp;Web applications are typically backed by a database. &nbsp;Often, developers use a distributed in-memory key-value store as a caching layer to absorb the load to the backend database. &nbsp;State-of-the-art key-value systems only cache basic data items. As a result, programmers have to manually cache various derived data (such as the result of a join query). &nbsp;We have developed the Pequod system to shift the burden of maintaining the consistency of derived data onto the cache. &nbsp;Pequod calculates views on demand, incrementally updates them as required, and in many cases improves performance by reducing client communication.</p>\n<p><br />Another major challenge facing distributed key-value stores is how to provide fault tolerance while achieving high performance. &nbsp;In the traditional approach, data must be synchronously stored on the disks of a majority of replica nodes. &nbsp;Unfortunately, such synchronous replication increases operation latency and lowers overall throughput. &nbsp;We have demonstrated how to achieve fault-tolerant asynchronous replication with the Lazen key-value system. &nbsp;Lazen first records operations in volatil...",
  "por_txt_cntn": "\nIn the era of ``Big Data'', many programmers whose backgrounds are not in computer science (e.g. business, natural and social sciences) wish to process an enormous amount of data using thousands of machines in the cloud.  However, it is extraordinarily difficult to write programs that run on many machines, even for expert programmers who are well trained in programming distributed systems.  The goal of this project is to develop programming and storage infrastructures that can hide the complexities of distribution and simplify the task of writing distributed applications.  \n\n\nDistributed programming frameworks make it easy to write large-scale offline batch computation, such as text analytic, machine learning algorithms etc.  Prior to this project's work, the state-of-the-art distributed programming framework was Google's MapReduce (and its open-source clone, Hadoop).  While MapReduce works well for large-scale text processing, it is a bad fit for large classes of important applications in machine learning, scientific computing and computational biology.  These applications can hold all their intermediate state in memory and need to share this intermediate state between machines during computation.  As MapReduce lacks support for distributed state, it is awkward and inefficient to write these applications in MapReduce.  This project has developed the Piccolo programming framework for these stateful, in-memory applications.  To better support in-memory computation, Piccolo explicitly provides the sharing of mutable, distributed state across machines via a key/value table interface.  Piccolo makes sharing efficient by providing simple primitives that programmers can use to optimize for locality of access to shared tables and to resolve write-write conflicts using user-defined accumulation functions.  As a result, it is easy to program in Piccolo, and it enables applications that are not handled well by MapReduce. \n\nPiccolo is designed and built for a cluster of CPU machines.  With the recent explosion of interests in deep neural networks, there is a surging demand for distributing expensive neural network training across many GPU machines.  We have developed the Skynet distributed training system to investigate the challenges and scalability limits of distributed neural network training.  We have found that the simple synchronous stochastic gradient descent strategy used by Skynet performs well up to a dozen GPU machines.\n\nApart from offline batch computation (such as PageRank, neural network training), another important class of applications is web applications, characterized by their online storage-intensive workloads.  Web applications are typically backed by a database.  Often, developers use a distributed in-memory key-value store as a caching layer to absorb the load to the backend database.  State-of-the-art key-value systems only cache basic data items. As a result, programmers have to manually cache various derived data (such as the result of a join query).  We have developed the Pequod system to shift the burden of maintaining the consistency of derived data onto the cache.  Pequod calculates views on demand, incrementally updates them as required, and in many cases improves performance by reducing client communication.\n\n\nAnother major challenge facing distributed key-value stores is how to provide fault tolerance while achieving high performance.  In the traditional approach, data must be synchronously stored on the disks of a majority of replica nodes.  Unfortunately, such synchronous replication increases operation latency and lowers overall throughput.  We have demonstrated how to achieve fault-tolerant asynchronous replication with the Lazen key-value system.  Lazen first records operations in volatile RAM while asynchronously writing to replicas' disks in the background.  A key technique of Lazen is to restore identical states to replicas even after some or all lose their memory of recent operations.  As a resul..."
 }
}